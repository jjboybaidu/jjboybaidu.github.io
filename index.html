<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>太阳在的地方</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="太阳在的地方">
<meta property="og:url" content="williamliuwen.cn/index.html">
<meta property="og:site_name" content="太阳在的地方">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="太阳在的地方">
<meta name="twitter:description">
  
  
    <link rel="icon" href="img/favicon.gif">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="img/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">刘 小汶</a></h1>
		</hgroup>

		
		<p class="header-subtitle">知我者谓我心忧，不知我者谓我何求。</p>
		

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/about">关于小汶</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
					        
						</div>
					</nav>
				</section>
				
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">刘 小汶</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="img/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">刘 小汶</h1>
			</hgroup>
			
			<p class="header-subtitle">知我者谓我心忧，不知我者谓我何求。</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/about">关于小汶</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-iOS-Map" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/01/iOS-Map/" class="article-date">
  	<time datetime="2016-08-01T14:31:01.000Z" itemprop="datePublished">2016-08-01</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/01/iOS-Map/">iOS-Map</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-iOS-Location" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/31/iOS-Location/" class="article-date">
  	<time datetime="2016-07-31T03:07:55.000Z" itemprop="datePublished">2016-07-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/31/iOS-Location/">iOS Location</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Location常识？"><a href="#1-Location常识？" class="headerlink" title="1.Location常识？"></a>1.Location常识？</h2><p>1).基于GPS/基站/wifi定位</p>
<p>3种区别是：iOS不像Android系统在定位服务编程时，可以指定采用哪种途径进行定位。iOS的API把底层这些细节屏蔽掉了，开发人员和用户并不知道现在设备是采用哪种方式进行定位的，iOS系统会根据设备的情况和周围的环境，采用一套最佳的解决方案。这个方案是这样的，如果能够接收GPS信息，那么设备优先采用GPS定位，否则采用Wifi或蜂窝基站定位，在Wifi和蜂窝基站之间优先使用Wifi，如果无法连接Wifi才使用蜂窝基站定位。总体来说GPS定位优点是准确、覆盖面广阔，缺点是不能被遮挡（例如：在建筑物里面收不到GPS卫星信号）、GPS开启后比较费电。蜂窝基站不仅误差比较大，而且会耗费用户流量费。而Wifi定位是最经济实惠的。</p>
<p>2).如果使用基站进行定位,必须要求设备有电话模块</p>
<ul>
<li><p>2.1）当app被完全关闭时,也可以接收到位置通知,并让app进入到后台处理 </p>
</li>
<li><p>2.2）定位精度相比于上面,精度不大,所以耗电小,而且定位更新频率依据基站密度而定</p>
</li>
</ul>
<p>3).必须开启手机位置服务</p>
<p>4).位置更新的评估标准有：高精度低频率、高精度高频率、低精度低频率、低精度高频率</p>
<h2 id="2-Location使用的框架？"><a href="#2-Location使用的框架？" class="headerlink" title="2.Location使用的框架？"></a>2.Location使用的框架？</h2><p>1.CLLocatin Framework API</p>
<h2 id="3-Location注意点？"><a href="#3-Location注意点？" class="headerlink" title="3.Location注意点？"></a>3.Location注意点？</h2><p>1).对iOS9+，需要加allowsBackgroundLocationUpdates = YES</p>
<p>2).后台位置更新会用到的方法</p>
<ul>
<li><p>UIApplication:beginBackgroundTaskWithExpirationHandler:</p>
</li>
<li><p>UIApplication:backgroundTimeRemaining</p>
</li>
</ul>
<p>3).后台运行位置判断精度</p>
<ul>
<li>if(newLocation.horizontalAccuracy &gt; 100) return; //精度&gt; 100米</li>
</ul>
<p>4).后台运行位置更新</p>
<ul>
<li>在处理位置数据的时候尽量减少工作量</li>
</ul>
<h2 id="4-Location遇到的问题？"><a href="#4-Location遇到的问题？" class="headerlink" title="4.Location遇到的问题？"></a>4.Location遇到的问题？</h2><p>1).后台位置更新需要更多的时间处理位置数据使用的方法是？</p>
<ul>
<li>If an iOS app needs more time to process the location data, it can request more background execution time using beginBackgroundTaskWithName:expirationHandler:</li>
</ul>
<p>2).位置更新后台运行资源紧张问题?</p>
<ul>
<li>如果使用startUpdatingLocation，当有更新时遇到资源紧张，则会被延迟调用委托。如果对于实时性要求高的可能不适合这个，很难控制用户机器性能状况。</li>
</ul>
<p>3).APP挂了，怎么重新运行位置更新?</p>
<ul>
<li>使用 region monitoring 或者 使用 significant-change location service.</li>
</ul>
<p>4).后台运行位置离上次更新时间?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSTimeInterval howRecent = [newLocation.timestamp timeIntervalSinceNow];</span><br><span class="line"></span><br><span class="line">if(howRecent &lt; -10) return ； //离上次更新的时间少于10秒</span><br></pre></td></tr></table></figure>
<h2 id="5-Location两种服务"><a href="#5-Location两种服务" class="headerlink" title="5.Location两种服务?"></a>5.Location两种服务?</h2><h4 id="标准位置服务-Standard-Location-Service"><a href="#标准位置服务-Standard-Location-Service" class="headerlink" title="标准位置服务 Standard Location Service"></a>标准位置服务 Standard Location Service</h4><ul>
<li><p>1).可以提供持续的位置更新</p>
</li>
<li><p>2).可以提供最精确的位置更新</p>
</li>
<li><p>3).如果被用户手动关闭，就不会再被唤醒</p>
</li>
<li><p>4).定位基于gps/基站/wifi定位</p>
</li>
<li><p>5).使用场景：定位及时,精度较高,并且运行时间较短;</p>
</li>
</ul>
<hr>
<h4 id="显著的位置变化定位服务-significant-change-location-service"><a href="#显著的位置变化定位服务-significant-change-location-service" class="headerlink" title="显著的位置变化定位服务 significant-change location service"></a>显著的位置变化定位服务 significant-change location service</h4><ul>
<li><p>1).提供至少15分钟一次的位置更新</p>
</li>
<li><p>2).无法提供精确的位置更新</p>
</li>
<li><p>3).可以重新启动位置更新服务</p>
</li>
<li><p>4).使用基站定位的，所以设备一定要有电话模块</p>
</li>
<li><p>5).不管是在后台还是用户手动关闭APP都会被唤醒调用委托,只有3种方法关闭1）用户关闭定位服务（2）用户关闭对该app的定位服务（3）设备处于飞行模式或者无法开启必要的硬件</p>
</li>
<li><p>6).startMonitoringSignificantLocationChanges什么时候更新呢？是在更换基站的时候更新。所以更新频率与基站密度有关。市区更新频率较郊区高。所以很多同学说没有更新是因为还在同一组基站范围内。</p>
</li>
<li><p>7).使用场景：长时间监控用户位置,用户移动速度比较快(例如打车软件)，为什么打车软件适用呢，说明一下，因为坐车使用APP的话，移动的速度快，距离变化非常明显，所以使用这种方式。这种方式适用长时间监控，但长时间监控不能保持实时监控，就会导致后台不会时刻运行位置更新服务，而是在使用的时候才会调用，这个是由苹果系统控制，iOS开发者无法控制。</p>
</li>
</ul>
<h2 id="6-Location省电最佳实践"><a href="#6-Location省电最佳实践" class="headerlink" title="6.Location省电最佳实践"></a>6.Location省电最佳实践</h2><ul>
<li><p>1.pausesLocationUpdatesAutomatically 设置为YES</p>
</li>
<li><p>2.activityType 设置这个属性，例如设置为 CLActivityTypeAutomotiveNavigation :<br>causes the location manager to pause events only when the user does not move a significant distance over a period of time</p>
</li>
</ul>
<p>3.</p>
<ul>
<li><p>1）allowDeferredLocationUpdatesUntilTraveled:timeout:允许延迟更新</p>
</li>
<li><p>2）结合 locationManager:didFinishDeferredUpdatesWithError:使用， 当 stopped deferring the delivery of location updates的时候调用</p>
</li>
<li><p>3）停止延迟更新的方法：disallowDeferredLocationUpdates </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Delegate method from the CLLocationManagerDelegate protocol.</span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager</span><br><span class="line">didUpdateLocations:(NSArray *)locations &#123;</span><br><span class="line">// Add the new locations to the hike</span><br><span class="line">[self.hike addLocations:locations];</span><br><span class="line"></span><br><span class="line">参数locations是位置变化的聚拢，它按照时间变化的顺序存放。如果想获得当前设备的位置，可以使用第①行的[locations lastObject]语句获得聚拢中最后一个元素，它就是设备当前位置了。</span><br><span class="line"></span><br><span class="line">CLLocation封装了位置、高度等信息。在上面代码中我们使用了它的两个属性：altitude和coordinate，altitude属性是高度值，coordinate是封装了经度和纬度的结构体CLLocationCoordinate2D</span><br><span class="line"></span><br><span class="line">CLLocationCoordinate2D;其中latitude为经度信息，longitude为纬度信息，它们都是CLLocationDegrees类型，CLLocationDegrees是使用typedef定义的double类型。</span><br><span class="line"></span><br><span class="line">// Defer updates until the user hikes a certain distance</span><br><span class="line">// or when a certain amount of time has passed.</span><br><span class="line">if (!self.deferringUpdates) &#123;</span><br><span class="line">CLLocationDistance distance = self.hike.goal - self.hike.distance;</span><br><span class="line">NSTimeInterval time = [self.nextAudible timeIntervalSinceNow];</span><br><span class="line">[locationManager allowDeferredLocationUpdatesUntilTraveled:distance</span><br><span class="line">timeout:time];</span><br><span class="line">self.deferringUpdates = YES;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-Location常用属性和方法？"><a href="#7-Location常用属性和方法？" class="headerlink" title="7.Location常用属性和方法？"></a>7.Location常用属性和方法？</h2><h4 id="activityType："><a href="#activityType：" class="headerlink" title="activityType："></a>activityType：</h4><p>设置定位数据的用途</p>
<ul>
<li><p>CLActivityTypeOther（定位数据作为普通用途）</p>
</li>
<li><p>CLActivityTypeFitness（定位数据作为步行导航使用）</p>
</li>
<li><p>CLActivityTypeOtherNavigation（定位数据作为其他导航使用）</p>
</li>
<li><p>CLActivityTypeAutomotiveNavigation（定位数据作为车辆导航使用）</p>
</li>
</ul>
<hr>
<h4 id="distanceFilter："><a href="#distanceFilter：" class="headerlink" title="distanceFilter："></a>distanceFilter：</h4><ul>
<li><p>设置CLLocationManager的自动过滤距离。</p>
</li>
<li><p>也就是说，只有当设备在水平方向的位置改变超过该数值（以米为单位）指定的距离时才会生成一次位置改变的信号。</p>
</li>
<li><p>每隔多少米定位一次</p>
</li>
<li><p>代码: self.locationM.distanceFilter = 100;</p>
</li>
<li><p>功能：只有当最新的位置与上一次获取的位置之间的距离, 大于这个值时, 才会通过代理告诉外界.</p>
</li>
</ul>
<hr>
<h4 id="pausesLocationUpdatesAutomatically："><a href="#pausesLocationUpdatesAutomatically：" class="headerlink" title="pausesLocationUpdatesAutomatically："></a>pausesLocationUpdatesAutomatically：</h4><ul>
<li>设置iOS设备是否可暂停定位来节省电池的电量。如果该属性设为“YES”，则当iOS设备不再需要定位数据时，iOS设备可以自动暂停定位。</li>
</ul>
<hr>
<h4 id="desiredAccuracy"><a href="#desiredAccuracy" class="headerlink" title="desiredAccuracy"></a>desiredAccuracy</h4><ul>
<li><p>设置定位精确度</p>
</li>
<li><p>代   码: self.locationM.desiredAccuracy = kCLLocationAccuracyBest;</p>
</li>
<li><p>功   能: 通过设置此属性, 获取不同精确度的位置信息;</p>
</li>
<li><p>注意事项: 精确度越高，越耗电，定位所需时间越长</p>
</li>
<li><p>1) kCLLocationAccuracyBestForNavigation    最适合导航</p>
</li>
<li>2) kCLLocationAccuracyBest    精度最好的</li>
<li>3) kCLLocationAccuracyNearestTenMeters    附近10米</li>
<li>4) kCLLocationAccuracyHundredMeters    附近100米</li>
<li>5) kCLLocationAccuracyKilometer    附近1000米</li>
<li><p>6) kCLLocationAccuracyThreeKilometers    附近3000米</p>
</li>
<li><p>精度越高请求获得位置信息的时间就越短，这就意味着设备越耗电。因此一个应用应该选择适合它的精度</p>
</li>
<li><p>如果你的应用是一个车载导航应用，kCLLocationAccuracyBestForNavigation是比较好的选择，你可以使用汽车上的电瓶为设备供电。</p>
</li>
<li><p>如果你的应用为徒步旅行者供给的导航应用，kCLLocationAccuracyHundredMeters是一个不错的选择。</p>
</li>
</ul>
<hr>
<h4 id="CLLocation"><a href="#CLLocation" class="headerlink" title="CLLocation"></a>CLLocation</h4><p>CLLocation类代表一个位置信息，其中还包括了方向和速度。比如我在长安街188号以5公里/小时的速度往西走。CLLocation具有下面的属性和方法：</p>
<ul>
<li><p>@property  CLLocationCoordinate2D coordinate; //以经度和纬度表示的位置信息</p>
</li>
<li><p>@property CLLocationDistance altitude;  //海拔</p>
</li>
<li><p>@property CLLocationAccuracy horizontalAccuracy; //水平精度（如：精确到米）</p>
</li>
<li><p>@property CLLocationAccuracy verticalAccuracy; //垂直精度</p>
</li>
<li><p>@property CLLocationDirection course; //方向</p>
</li>
<li><p>@property CLLocationSpeed speed; //速度</p>
</li>
<li><p>-（NSDate*）timeStamp;</p>
</li>
<li><p>-(CLLocationDistance)distanceFromLocation:(CLLocation*)location;//两个位置之间的距离</p>
</li>
</ul>
<hr>
<h4 id="CLLocationManager"><a href="#CLLocationManager" class="headerlink" title="CLLocationManager"></a>CLLocationManager</h4><p>CLLocationManager类管理和提供位置服务,CLLocationManager是定位服务管理类它能够给我们供给获得设备的位置信息和高度信息，也可以监控设备进入或离开某个区域，它还可以帮助获得设备的运行方向等</p>
<ul>
<li><p>@property CLLocation *location; //位置</p>
</li>
<li><p>@property id<cllocationmanagerdelegate> delegate;</cllocationmanagerdelegate></p>
</li>
<li><p>@property CLLocationDistance distanceFilter; //距离过滤，比如：500以内</p>
</li>
<li><p>@property CLlocationAccuracy verticalAccuracy; //垂直精度</p>
</li>
<li><p>-(void) startUpdatingLocation; //开始更新位置（比如：你在往某个地方走）</p>
</li>
<li><p>-(void)stopUpdatingLocation; //停止更新位置</p>
</li>
<li><p>-(void)startUpdatingHeading; //开始更新方向（比如：你改往东走）</p>
</li>
<li><p>-(void)stopUpdatingHeading; //停止更新方向</p>
</li>
<li><p>CLLocationManagerDelegate是一个委托类。你的应用程序需要使用这个委托类。</p>
</li>
<li><p>-(void)locationManager:(CLLocationManager<em>)manager didUpdateToLocation:(CLLocation</em>)newLocation fromLocation:(CLLocation*)oldLocation;//当用户改变位置的时候回调</p>
</li>
<li><p>-(void)locationManager:(CLLocationManager<em>)manager didUpdateHeading:(CLLHeading</em>)newHeading;//当用户改变方向的时候回调</p>
</li>
<li><p>-(void)locationManager: (CLLocationManager <em>)manager didFailLoadWithError:(NSError </em>)error;//当iPhone无法获得当前位置的信息时回调</p>
</li>
<li><p>locationManagerDidPauseLocationUpdates://当停止位置更新回调</p>
</li>
<li><p>locationManagerDidResumeLocationUpdates: //当继续位置更新回调</p>
</li>
</ul>
<h5 id="本文参考链接"><a href="#本文参考链接" class="headerlink" title="本文参考链接"></a>本文参考链接</h5><p>1.<a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/CoreLocation/CoreLocation.html#//apple_ref/doc/uid/TP40009497-CH2-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/CoreLocation/CoreLocation.html#//apple_ref/doc/uid/TP40009497-CH2-SW1</a></p>
<p>2.<a href="http://stackoverflow.com/questions/19042894/periodic-ios-background-location-updates" target="_blank" rel="external">http://stackoverflow.com/questions/19042894/periodic-ios-background-location-updates</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-hexo-部署" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/23/hexo-部署/" class="article-date">
  	<time datetime="2016-07-23T02:53:57.000Z" itemprop="datePublished">2016-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/23/hexo-部署/">hexo 部署</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="部署hexo前提准备"><a href="#部署hexo前提准备" class="headerlink" title="部署hexo前提准备"></a>部署hexo前提准备</h4><p>1.到node.js 网站 <a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a>  下载node.js 直接安装，安装完，查看版本 ，node -v</p>
<p>2.到homebrew 网站  <a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="external">http://brew.sh/index_zh-cn.html</a> 使用下面的命令安装,如果安装失败，使用sudo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure>
<h4 id="开始部署hexo"><a href="#开始部署hexo" class="headerlink" title="开始部署hexo"></a>开始部署hexo</h4><p>1.使用下面的命令，一条一条来，如果不行，用sudo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>2.直接访问本地部署好的hexo</p>
<h4 id="利用hexo发布文章"><a href="#利用hexo发布文章" class="headerlink" title="利用hexo发布文章"></a>利用hexo发布文章</h4><p>1.新建文章，先进入hexo文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;新文章&quot;</span><br></pre></td></tr></table></figure>
<p>2.写好文章后，生成静态文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>3.生成静态文件后，上传到github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<h4 id="hexo技巧"><a href="#hexo技巧" class="headerlink" title="hexo技巧"></a>hexo技巧</h4><p>1.因为hexo生成的静态文件是放在public文件夹下面的，如果你部署github的时候，使用的git destop版本来上传代码的话，你可以clone你的git下来的时候，clone到hexo文件下，且改名为public，那么下次hexo生成静态文件的时候就会直接生成到clone下来的git文件夹里面，那你用git desktop上传代码的时候，就可以直接commit上传了</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-NSRunLoop" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/23/NSRunLoop/" class="article-date">
  	<time datetime="2016-07-23T00:35:55.000Z" itemprop="datePublished">2016-07-23</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/23/NSRunLoop/">NSRunLoop</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h4 id="运行循环本质"><a href="#运行循环本质" class="headerlink" title="运行循环本质"></a>运行循环本质</h4><p>1.从字面上看，就是运行循环跑圈</p>
<p>2.其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer）</p>
<p>3.循环体的开始需要检测是否有需要处理的事件，如果有则去处&gt; - 理，如果没有则进入睡眠以节省CPU时间</p>
<h4 id="FIXME-0-运行循环-概念性的东西有？"><a href="#FIXME-0-运行循环-概念性的东西有？" class="headerlink" title="FIXME:0.运行循环 概念性的东西有？"></a>FIXME:0.运行循环 概念性的东西有？</h4><p>概念1【输入源==事件源】<br>具体查看《RunLoop【输入源】》</p>
<p>概念2【模式】<br>具体查看《RunLoop【模式】》</p>
<p>概念3【观察者Observer】<br>具体查看《RunLoop【观察者】》</p>
<h4 id="FIXME-1-运行循环-为什么要使用运行循环"><a href="#FIXME-1-运行循环-为什么要使用运行循环" class="headerlink" title="FIXME:1.运行循环 为什么要使用运行循环"></a>FIXME:1.运行循环 为什么要使用运行循环</h4><p>1.我们思考一下：程序为什么可以处理用户的各种事件，而且可以保证程序不退出？答案：就是因为程序里面有个系统的默认运行循环，所以能保证程序不退出，并且处理用户的各种事件</p>
<p>2.想要了解为什么要使用运行循环，我们可以从使用运行循环的目的来了解，使用了运行循环我们可以：<br>a. 保证程序不退出 ;<br>b. 负责处理输入事件;<br>c. 如果没有事件发生，会让程序进入休眠状态。<br>从上面可以得出结论，为什么要使用运行循环，因为这是一个APP的基本，没有运行循环，就没有APP的正常运行。</p>
<p>3.通过上面的了解我们可以总结运行循环的优点：有事情就做事情，没事情就休息；优点：节省CPU资源、提高程序性能；</p>
<h4 id="FIXME-2-运行循环-程序里哪里存在运行循环"><a href="#FIXME-2-运行循环-程序里哪里存在运行循环" class="headerlink" title="FIXME:2.运行循环 程序里哪里存在运行循环"></a>FIXME:2.运行循环 程序里哪里存在运行循环</h4><p>1.【系统默认 运行循环】系统默认就是一个运行循环，可以保证程序不死掉；系统默认运行循环在主线程</p>
<h4 id="FIXME-3-运行循环-与线程的关系"><a href="#FIXME-3-运行循环-与线程的关系" class="headerlink" title="FIXME:3.运行循环 与线程的关系"></a>FIXME:3.运行循环 与线程的关系</h4><p>1.每一个线程内部都有一个消息循环。只有主线程的消息循环默认开启,子线程的消息循环默认不开启，一个运行循环对应着一条唯一的线程，如何让子线程不死 ，给这条子线程开启一个运行循环，子线程的runloop需要手动创建,需要手动开启</p>
<p>2.线程在执行中的休眠和激活就是由RunLoop对象进行管理的</p>
<p>3.RunLoop是用来管理线程的</p>
<p>4.每一个线程都有一个RunLoop对象。可以通过具体的方法去获得</p>
<p>5.但是需要注意：虽然每一个线程都可以获取RunLoop对象，但是并不是每一个线程中都有实例对象，我们可以这样理解：如果我们不获取RunLoop，这个RunLoop就不存在，我们获取时，如果不存在，就会去创建。在主线程中，这个MainRunLoop是默认创建并运行激活的</p>
<p>6.每条线程都有唯一的一个与之对应的RunLoop对象</p>
<h4 id="FIXME-4-运行循环-生命周期"><a href="#FIXME-4-运行循环-生命周期" class="headerlink" title="FIXME:4.运行循环 生命周期"></a>FIXME:4.运行循环 生命周期</h4><p>1.运行循环的生命周期：在第一次获取时创建，在线程结束时销毁</p>
<h4 id="FIXME-5-运行循环-基本运行流程"><a href="#FIXME-5-运行循环-基本运行流程" class="headerlink" title="FIXME:5.运行循环 基本运行流程"></a>FIXME:5.运行循环 基本运行流程</h4><p>1.创建消息（即输入源）；</p>
<p>2.指定该事件（源）在循环中运行的模式，并加入循环；</p>
<p>3.当事件的模式与消息循环的模式匹配的时候，消息才会运行。</p>
<p>4.运行逻辑总结：一个线程对应一个runLoop,主线程的runloop是程序一启动,默认就创建一个runloop,创建好了之后就会给它添加一些默认的模式,每个模式里面会有很多的 source /timer/observer ,添加好这些模式后,observer就会监听主线程的runloop,进入runloop后,就开始处理事件,先处理timer,再处理source0,source0处理完之后再处理source1,当把这些所有的事件反复的处理完之后,如果没有事件了,那么runloop就会进入睡眠状态,当用户又触发了新的事件,就会唤醒runloop,唤醒runloop后回到第二步,重新处理新的timer,新的source0,新的source1,处理完后就睡眠,一直反复,当我们把程序关闭或者强退,这个时候observer就会监听都runloop退出了.</p>
<h4 id="FIXME-6-运行循环-API"><a href="#FIXME-6-运行循环-API" class="headerlink" title="FIXME:6.运行循环 API"></a>FIXME:6.运行循环 API</h4><p>1.NSRunloop</p>
<p>2.CFRunLoopRef</p>
<p>3.两种API的区别1：NSRunloop线程不安全，CFRunLoopRef线程安全；NSRunLoop是Cocoa框架中的类，与之对应的是在Core Fundation中有一个CFRunLoopRef类。这两者的区别是前者不是线程安全的，而CFRunLoopRef是线程安全的。所以：NSRunloop不能调用其他线程的方法.The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results.</p>
<p>4.两种API的区别2：CFRunLoopRef创建一个timer必须添加到runloop 才会执行,添加的时候要指定模式 defaurce模式 ,不对程序做任何操作 timer就会后台运行 ,当我进行操作的时候runloop模式就会从默认模式切换到其他模式,假如说我操作scrollerView 它就会从default模式切换到tracking模式。而roonloop 同一时刻只能执行一种模式.</p>
<p>5.NSRunLoop是基于CFRunLoopRef的一层OC包装，提供了面向对象的 API，但是这些 API 不是线程安全的。所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）</p>
<h4 id="FIXME-7-运行循环-启动"><a href="#FIXME-7-运行循环-启动" class="headerlink" title="FIXME:7.运行循环 启动"></a>FIXME:7.运行循环 启动</h4><p>启动的三种方式：</p>
<p>1.无条件的—-无条件的进入Runloop是最简单的方法，但也最不推荐使用的。因为这样会使你的线程处在一个永久的循环中，这会让你对Runloop本身的控制很少。你可以添加或删除输入源和定时器，但是退出Runloop的唯一方法是杀死它。没有任何办法可以让这Runloop运行在自定义模式下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] run];</span><br></pre></td></tr></table></figure></p>
<p>2.设置超时时间—-替代无条件进入Runloop更好的办法是用预设超时时间来运行Runloop，这样Runloop运作直到某一事件到达或者规定的时间已经到期。如果是事件到达，消息会被传递给相应的处理程序来处理，然后Runloop退出。你可以重新启动Runloop来等待下一事件。如果是规定时间到期了，你只需简单的重启Runloop或使用此段时间来做任何的其他工作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]]; 2 秒钟之后结束</span><br></pre></td></tr></table></figure></p>
<p>3.特定的模式—-除了超时机制，你也可以使用特定的模式来运行你的Runloop。模式和超时不是互斥的，他们可以在启动RunLoop的时候同时使用。模式限制了可以传递事件给Runloop的输入源的类型。暂停当前处理的流程，转而处理其他输入源，当date设置为<a href="将来，基本不会到达的时间">NSDate distantFuture</a>，所以除非处理其他输入源结束，否则永不退出处理暂停的当前处理的流程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br></pre></td></tr></table></figure>
<h4 id="FIXME-8-运行循环-结束"><a href="#FIXME-8-运行循环-结束" class="headerlink" title="FIXME:8.运行循环 结束"></a>FIXME:8.运行循环 结束</h4><p>结束的三种方式：</p>
<p>1.给RunLoop设置超时时间</p>
<p>2.通知RunLoop停止—-如果可以配置的话，推荐使用第一种方法。指定一个超时时间可以使RunLoop退出前完成所有正常操作，包括发送消息给RunLoop观察者。</p>
<p>3.使用CFRunLoopStop来显式的停止RunLoop和使用超时时间产生的结果相似。RunLoop把所有剩余的通知发送出去再退出。与设置超时的不同的是你可以在无条件启动的RunLoop里面使用该技术。</p>
<h4 id="FIXME-9-运行循环-添加输入源"><a href="#FIXME-9-运行循环-添加输入源" class="headerlink" title="FIXME:9.运行循环 添加输入源"></a>FIXME:9.运行循环 添加输入源</h4><p>具体查看《NSRunLoop【例子<em>输入源</em>】》</p>
<h4 id="FIXME-10-运行循环-移除输入源"><a href="#FIXME-10-运行循环-移除输入源" class="headerlink" title="FIXME:10.运行循环 移除输入源"></a>FIXME:10.运行循环 移除输入源</h4><p>1.输入源被注册到RunLoop中时会有方法进行remove。但是定时器没有remove，但是它的invalidate方法可以将其从RunLoop中移除。invalidate是重要的也是唯一的将定时器从RunLoop中注销的方法，所以如果我们创建了定时器，就一定要再不适用的时候调用invalidate方法。</p>
<p>2.自动释放池,什么时候创建和释放 ?<br>(1)第一次创建:是在runloop进入的时候创建 对应的状态 = KCFRunLoopEntry<br>(2)最后一个退出,是在runloop退出的时候 对应的状态 = KCFRunLoopExit<br>(3)其他的创建和释放<br>每次睡觉的时候会释放前自动释放池,再创建一个新的<br>即将进入睡眠的时候,先释放上一次创建的自动释放池,然后再创建一个新的释放池</p>
<h4 id="FIXME-11-运行循环-能运行的关键"><a href="#FIXME-11-运行循环-能运行的关键" class="headerlink" title="FIXME:11.运行循环 能运行的关键"></a>FIXME:11.运行循环 能运行的关键</h4><p>1.每次运行一个RunLoop，你指定（显式或隐式）RunLoop的运行模式。当相应的模式传递给RunLoop时，只有与该模式对应的Input Source才被监控并允许RunLoop对事件进行处理（与此类似，也只有与该模式对应的Observers才会被通知）</p>
<p>2.上面的对应关系是：</p>
<p>RunLoop—-模式—-<br>模式—-Input Sources<br>模式—-Observers</p>
<h4 id="FIXME-12-运行循环-可以对运行循环做的操作"><a href="#FIXME-12-运行循环-可以对运行循环做的操作" class="headerlink" title="FIXME:12.运行循环 可以对运行循环做的操作"></a>FIXME:12.运行循环 可以对运行循环做的操作</h4><p>1.添加输入源；添加定时源；添加观察者；</p>
<h4 id="FIXME-13-运行循环-获得RunLoop对象"><a href="#FIXME-13-运行循环-获得RunLoop对象" class="headerlink" title="FIXME:13.运行循环 获得RunLoop对象"></a>FIXME:13.运行循环 获得RunLoop对象</h4><p>Foundation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[NSRunLoop currentRunLoop];   // 获得当前线程的RunLoop对象</span><br><span class="line">[NSRunLoop mainRunLoop];      // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure>
<p>Core Foundation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoopGetCurrent();       // 获得当前线程的RunLoop对象</span><br><span class="line">CFRunLoopGetMain();          // 获得主线程的RunLoop对象</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-提升自己" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/06/提升自己/" class="article-date">
  	<time datetime="2016-06-06T12:02:32.000Z" itemprop="datePublished">2016-06-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/06/提升自己/">提升自己</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="疑问："><a href="#疑问：" class="headerlink" title="疑问："></a>疑问：</h3><ul>
<li><p>1.为什么要学这些？</p>
</li>
<li><p>2.什么是系统性的目标？</p>
</li>
<li><p>3.如何利用有限时间最大化自己的长期收益</p>
</li>
</ul>
<h3 id="行动："><a href="#行动：" class="headerlink" title="行动："></a>行动：</h3>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a  href="/2016/06/06/提升自己/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 刘 小汶
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>