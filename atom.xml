<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阿汶的博客</title>
  <subtitle>知我者谓我心忧 不知我者谓我何求</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="williamliuwen.cn/"/>
  <updated>2016-08-13T13:36:36.000Z</updated>
  <id>williamliuwen.cn/</id>
  
  <author>
    <name>阿汶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS-Map</title>
    <link href="williamliuwen.cn/2016/08/10/AWblog/2016/8/iOS-Map/"/>
    <id>williamliuwen.cn/2016/08/10/AWblog/2016/8/iOS-Map/</id>
    <published>2016-08-10T14:31:01.000Z</published>
    <updated>2016-08-13T13:36:36.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-Location</title>
    <link href="williamliuwen.cn/2016/08/01/AWblog/2016/8/iOS-Location/"/>
    <id>williamliuwen.cn/2016/08/01/AWblog/2016/8/iOS-Location/</id>
    <published>2016-08-01T03:07:55.000Z</published>
    <updated>2016-08-13T13:36:27.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;1-Location常识？&quot;&gt;&lt;a href=&quot;#1-Location常识？&quot; class=&quot;headerlink&quot; title=&quot;1.Location常识？&quot;&gt;&lt;/a&gt;1.Location常识？&lt;/h2&gt;&lt;p&gt;1)基于GPS/基站/wifi定位&lt;/p&gt;
&lt;p&gt;3种区别是：iOS不像Android系统在定位服务编程时，可以指定采用哪种途径进行定位。iOS的API把底层这些细节屏蔽掉了，开发人员和用户并不知道现在设备是采用哪种方式进行定位的，iOS系统会根据设备的情况和周围的环境，采用一套最佳的解决方案。这个方案是这样的，如果能够接收GPS信息，那么设备优先采用GPS定位，否则采用Wifi或蜂窝基站定位，在Wifi和蜂窝基站之间优先使用Wifi，如果无法连接Wifi才使用蜂窝基站定位。总体来说GPS定位优点是准确、覆盖面广阔，缺点是不能被遮挡（例如：在建筑物里面收不到GPS卫星信号）、GPS开启后比较费电。蜂窝基站不仅误差比较大，而且会耗费用户流量费。而Wifi定位是最经济实惠的。&lt;/p&gt;
&lt;p&gt;2)如果使用基站进行定位,必须要求设备有电话模块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2.1 当app被完全关闭时,也可以接收到位置通知,并让app进入到后台处理 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.2 定位精度相比于上面,精度不大,所以耗电小,而且定位更新频率依据基站密度而定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3)必须开启手机位置服务&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;4)位置更新的评估标准有：高精度低频率、高精度高频率、低精度低频率、低精度高频率&lt;/p&gt;
&lt;p&gt;5)LBS : Location Based Service（基于定位的服务）&lt;/p&gt;
&lt;p&gt;6)南北走向的是经线（ longitude），东西走向的是纬线（ latitude），例如北京的经度是119度，纬度是40度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本初子午线：穿过英国伦敦格林文治天文台&lt;/li&gt;
&lt;li&gt;往东边（右边）走，是东经（E）&lt;/li&gt;
&lt;li&gt;往西边（左边）走，是西经（W）&lt;/li&gt;
&lt;li&gt;东西经各180°，总共360°&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;赤道：零度维度&lt;/li&gt;
&lt;li&gt;往北边（上边）走，是北纬（N）&lt;/li&gt;
&lt;li&gt;往南边（下边）走，是南纬（S）&lt;/li&gt;
&lt;li&gt;南北纬各90°，总共180°&lt;/li&gt;
&lt;li&gt;提示：横跨经度\纬度越大（1° ≈ 111km），表示的范围就越大，在地图上看到的东西就越小&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;中国的经纬度范围&lt;/li&gt;
&lt;li&gt;纬度范围：N 3°51′ ~  N 53°33′&lt;/li&gt;
&lt;li&gt;经度范围：E 73°33′ ~  E 135°05′&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7）火星坐标（GCJ-02）与地球坐标系 (WGS-84)？&lt;/p&gt;
&lt;p&gt;标准地球坐标即GPS设备获得的坐标，该坐标需要经过国家测绘局进行加密后形成火星坐标（GCJ-02），我们用的google坐标和高德地图坐标也就是火星坐标，它们都是加了偏移坐标的；&lt;/p&gt;
&lt;p&gt;GPS模块获取到的坐标是WGS84坐标系的&lt;/p&gt;
&lt;p&gt;中国政府出于种种目的的考虑，不允许中国的地图使用国际通用的WGS84坐标系，而非要加上一些偏移，这样的坐标系就俗称“火星坐标系”；简单来说就是加了偏移的坐标就是火星坐标&lt;/p&gt;
&lt;p&gt;使用火星坐标常见错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比如在使用百度地图API的时候，因为百度地图是在火星坐标的基础上再进行一次加密，形成了百度地图上的坐标，因此，直接将标准地球坐标显示在百度地图上是会有几百米的偏差的。按照此原理，标准GPS坐标经过两步的转换可得到百度坐标。在实际开发中要注意这点。&lt;/li&gt;
&lt;li&gt;地图上几百米偏差出现的原因是：Google地图采用的也是加偏移过的火星坐标系，但GPS模块传给它的坐标却没有加偏移，于是就出现几百米的偏差了&lt;/li&gt;
&lt;li&gt;因为我们的地图应用无法使用标准的地球坐标，所以我们应该想办法把标准的地球坐标转换为火星坐标&lt;/li&gt;
&lt;li&gt;这也就是我们如果在开发需要地图应用的时候，需要经常使用第三方的API，必须百度地图，高德地图，谷歌地图的原因了，因为它们已经帮我们把标准的地球坐标通过它们自己的算法转换成了火星坐标了，而如果我们自己去写的话，那真的是一个大的工程；&lt;/li&gt;
&lt;li&gt;火星坐标的存在可以保护用户的位置隐私。&lt;/li&gt;
&lt;li&gt;原则上，根据我们的法律，都不允许分享任何带有经纬度的坐标系统，不管你是真实的WGS84坐标还是加密后的火星坐标。 &lt;/li&gt;
&lt;li&gt;如果你不是做导航软件、地图软件的公司，那么你就无法获得国测局的保密插件，如果你是用户，得到了火星坐标，那么也是无法逆转回地球坐标的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;2-Location使用的框架？&quot;&gt;&lt;a href=&quot;#2-Location使用的框架？&quot; class=&quot;headerlink&quot; title=&quot;2.Location使用的框架？&quot;&gt;&lt;/a&gt;2.Location使用的框架？&lt;/h2&gt;&lt;p&gt;1)Core Locatin Framework API&lt;/p&gt;
&lt;p&gt;2)CoreLocation框架中所有数据类型的前缀都是CL&lt;/p&gt;
&lt;p&gt;3)CoreLocation中使用CLLocationManager对象来做用户定位&lt;/p&gt;
&lt;h2 id=&quot;3-Location注意点？&quot;&gt;&lt;a href=&quot;#3-Location注意点？&quot; class=&quot;headerlink&quot; title=&quot;3.Location注意点？&quot;&gt;&lt;/a&gt;3.Location注意点？&lt;/h2&gt;&lt;p&gt;1).对iOS9+，需要加allowsBackgroundLocationUpdates = YES&lt;/p&gt;
&lt;p&gt;2).后台位置更新会用到的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;UIApplication:beginBackgroundTaskWithExpirationHandler:&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;UIApplication:backgroundTimeRemaining&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3).后台运行位置判断精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if(newLocation.horizontalAccuracy &amp;gt; 100) return; //精度&amp;gt; 100米&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4).后台运行位置更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在处理位置数据的时候尽量减少工作量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;4-Location遇到的问题？&quot;&gt;&lt;a href=&quot;#4-Location遇到的问题？&quot; class=&quot;headerlink&quot; title=&quot;4.Location遇到的问题？&quot;&gt;&lt;/a&gt;4.Location遇到的问题？&lt;/h2&gt;&lt;p&gt;1).后台位置更新需要更多的时间处理位置数据使用的方法是？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If an iOS app needs more time to process the location data, it can request more background execution time using beginBackgroundTaskWithName:expirationHandler:&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2).位置更新后台运行资源紧张问题?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果使用startUpdatingLocation，当有更新时遇到资源紧张，则会被延迟调用委托。如果对于实时性要求高的可能不适合这个，很难控制用户机器性能状况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3).APP挂了，怎么重新运行位置更新?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 region monitoring 或者 使用 significant-change location service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4).后台运行位置离上次更新时间?&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSTimeInterval howRecent = [newLocation.timestamp timeIntervalSinceNow];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(howRecent &amp;lt; -10) return ； //离上次更新的时间少于10秒&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;5-Location两种服务&quot;&gt;&lt;a href=&quot;#5-Location两种服务&quot; class=&quot;headerlink&quot; title=&quot;5.Location两种服务?&quot;&gt;&lt;/a&gt;5.Location两种服务?&lt;/h2&gt;&lt;h4 id=&quot;标准位置服务-Standard-Location-Service&quot;&gt;&lt;a href=&quot;#标准位置服务-Standard-Location-Service&quot; class=&quot;headerlink&quot; title=&quot;标准位置服务 Standard Location Service&quot;&gt;&lt;/a&gt;标准位置服务 Standard Location Service&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1).可以提供持续的位置更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2).可以提供最精确的位置更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3).如果被用户手动关闭，就不会再被唤醒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4).定位基于gps/基站/wifi定位&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5).使用场景：定位及时,精度较高,并且运行时间较短;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&quot;显著的位置变化定位服务-significant-change-location-service&quot;&gt;&lt;a href=&quot;#显著的位置变化定位服务-significant-change-location-service&quot; class=&quot;headerlink&quot; title=&quot;显著的位置变化定位服务 significant-change location service&quot;&gt;&lt;/a&gt;显著的位置变化定位服务 significant-change location service&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1).提供至少15分钟一次的位置更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2).无法提供精确的位置更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3).可以重新启动位置更新服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4).使用基站定位的，所以设备一定要有电话模块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5).不管是在后台还是用户手动关闭APP都会被唤醒调用委托,只有3种方法关闭1）用户关闭定位服务（2）用户关闭对该app的定位服务（3）设备处于飞行模式或者无法开启必要的硬件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;6).startMonitoringSignificantLocationChanges什么时候更新呢？是在更换基站的时候更新。所以更新频率与基站密度有关。市区更新频率较郊区高。所以很多同学说没有更新是因为还在同一组基站范围内。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;7).使用场景：长时间监控用户位置,用户移动速度比较快(例如打车软件)，为什么打车软件适用呢，说明一下，因为坐车使用APP的话，移动的速度快，距离变化非常明显，所以使用这种方式。这种方式适用长时间监控，但长时间监控不能保持实时监控，就会导致后台不会时刻运行位置更新服务，而是在使用的时候才会调用，这个是由苹果系统控制，iOS开发者无法控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;6-Location省电最佳实践&quot;&gt;&lt;a href=&quot;#6-Location省电最佳实践&quot; class=&quot;headerlink&quot; title=&quot;6.Location省电最佳实践&quot;&gt;&lt;/a&gt;6.Location省电最佳实践&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.pausesLocationUpdatesAutomatically 设置为YES&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.activityType 设置这个属性，例如设置为 CLActivityTypeAutomotiveNavigation :&lt;br&gt;causes the location manager to pause events only when the user does not move a significant distance over a period of time&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1）allowDeferredLocationUpdatesUntilTraveled:timeout:允许延迟更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2）结合 locationManager:didFinishDeferredUpdatesWithError:使用， 当 stopped deferring the delivery of location updates的时候调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3）停止延迟更新的方法：disallowDeferredLocationUpdates &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Delegate method from the CLLocationManagerDelegate protocol.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)locationManager:(CLLocationManager *)manager&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;didUpdateLocations:(NSArray *)locations &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Add the new locations to the hike&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.hike addLocations:locations];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参数locations是位置变化的聚拢，它按照时间变化的顺序存放。如果想获得当前设备的位置，可以使用第①行的[locations lastObject]语句获得聚拢中最后一个元素，它就是设备当前位置了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CLLocation封装了位置、高度等信息。在上面代码中我们使用了它的两个属性：altitude和coordinate，altitude属性是高度值，coordinate是封装了经度和纬度的结构体CLLocationCoordinate2D&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CLLocationCoordinate2D;其中latitude为经度信息，longitude为纬度信息，它们都是CLLocationDegrees类型，CLLocationDegrees是使用typedef定义的double类型。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Defer updates until the user hikes a certain distance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// or when a certain amount of time has passed.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!self.deferringUpdates) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CLLocationDistance distance = self.hike.goal - self.hike.distance;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSTimeInterval time = [self.nextAudible timeIntervalSinceNow];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[locationManager allowDeferredLocationUpdatesUntilTraveled:distance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeout:time];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.deferringUpdates = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;7-Location常用属性和方法？&quot;&gt;&lt;a href=&quot;#7-Location常用属性和方法？&quot; class=&quot;headerlink&quot; title=&quot;7.Location常用属性和方法？&quot;&gt;&lt;/a&gt;7.Location常用属性和方法？&lt;/h2&gt;&lt;h4 id=&quot;activityType：&quot;&gt;&lt;a href=&quot;#activityType：&quot; class=&quot;headerlink&quot; title=&quot;activityType：&quot;&gt;&lt;/a&gt;activityType：&lt;/h4&gt;&lt;p&gt;设置定位数据的用途&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CLActivityTypeOther（定位数据作为普通用途）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CLActivityTypeFitness（定位数据作为步行导航使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CLActivityTypeOtherNavigation（定位数据作为其他导航使用）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CLActivityTypeAutomotiveNavigation（定位数据作为车辆导航使用）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&quot;distanceFilter：&quot;&gt;&lt;a href=&quot;#distanceFilter：&quot; class=&quot;headerlink&quot; title=&quot;distanceFilter：&quot;&gt;&lt;/a&gt;distanceFilter：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置CLLocationManager的自动过滤距离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也就是说，只有当设备在水平方向的位置改变超过该数值（以米为单位）指定的距离时才会生成一次位置改变的信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每隔多少米定位一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代码: self.locationM.distanceFilter = 100;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功能：只有当最新的位置与上一次获取的位置之间的距离, 大于这个值时, 才会通过代理告诉外界.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&quot;pausesLocationUpdatesAutomatically：&quot;&gt;&lt;a href=&quot;#pausesLocationUpdatesAutomatically：&quot; class=&quot;headerlink&quot; title=&quot;pausesLocationUpdatesAutomatically：&quot;&gt;&lt;/a&gt;pausesLocationUpdatesAutomatically：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;设置iOS设备是否可暂停定位来节省电池的电量。如果该属性设为“YES”，则当iOS设备不再需要定位数据时，iOS设备可以自动暂停定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&quot;desiredAccuracy&quot;&gt;&lt;a href=&quot;#desiredAccuracy&quot; class=&quot;headerlink&quot; title=&quot;desiredAccuracy&quot;&gt;&lt;/a&gt;desiredAccuracy&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;设置定位精确度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;代   码: self.locationM.desiredAccuracy = kCLLocationAccuracyBest;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;功   能: 通过设置此属性, 获取不同精确度的位置信息;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意事项: 精确度越高，越耗电，定位所需时间越长&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1) kCLLocationAccuracyBestForNavigation    最适合导航&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;2) kCLLocationAccuracyBest    精度最好的&lt;/li&gt;
&lt;li&gt;3) kCLLocationAccuracyNearestTenMeters    附近10米&lt;/li&gt;
&lt;li&gt;4) kCLLocationAccuracyHundredMeters    附近100米&lt;/li&gt;
&lt;li&gt;5) kCLLocationAccuracyKilometer    附近1000米&lt;/li&gt;
&lt;li&gt;&lt;p&gt;6) kCLLocationAccuracyThreeKilometers    附近3000米&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;精度越高请求获得位置信息的时间就越短，这就意味着设备越耗电。因此一个应用应该选择适合它的精度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你的应用是一个车载导航应用，kCLLocationAccuracyBestForNavigation是比较好的选择，你可以使用汽车上的电瓶为设备供电。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你的应用为徒步旅行者供给的导航应用，kCLLocationAccuracyHundredMeters是一个不错的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&quot;CLLocation&quot;&gt;&lt;a href=&quot;#CLLocation&quot; class=&quot;headerlink&quot; title=&quot;CLLocation&quot;&gt;&lt;/a&gt;CLLocation&lt;/h4&gt;&lt;p&gt;CLLocation类代表一个位置信息，其中还包括了方向和速度。比如我在长安街188号以5公里/小时的速度往西走。CLLocation具有下面的属性和方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;@property  CLLocationCoordinate2D coordinate; //以经度和纬度表示的位置信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property CLLocationDistance altitude;  //海拔&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property CLLocationAccuracy horizontalAccuracy; //水平精度（如：精确到米）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property CLLocationAccuracy verticalAccuracy; //垂直精度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property CLLocationDirection course; //方向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property CLLocationSpeed speed; //速度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-（NSDate*）timeStamp;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(CLLocationDistance)distanceFromLocation:(CLLocation*)location;//两个位置之间的距离&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h4 id=&quot;CLLocationManager&quot;&gt;&lt;a href=&quot;#CLLocationManager&quot; class=&quot;headerlink&quot; title=&quot;CLLocationManager&quot;&gt;&lt;/a&gt;CLLocationManager&lt;/h4&gt;&lt;p&gt;CLLocationManager类管理和提供位置服务,CLLocationManager是定位服务管理类它能够给我们供给获得设备的位置信息和高度信息，也可以监控设备进入或离开某个区域，它还可以帮助获得设备的运行方向等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;@property CLLocation *location; //位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property id&lt;cllocationmanagerdelegate&gt; delegate;&lt;/cllocationmanagerdelegate&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property CLLocationDistance distanceFilter; //距离过滤，比如：500以内&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property CLlocationAccuracy verticalAccuracy; //垂直精度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void) startUpdatingLocation; //开始更新位置（比如：你在往某个地方走）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)stopUpdatingLocation; //停止更新位置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)startUpdatingHeading; //开始更新方向（比如：你改往东走）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)stopUpdatingHeading; //停止更新方向&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CLLocationManagerDelegate是一个委托类。你的应用程序需要使用这个委托类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)locationManager:(CLLocationManager&lt;em&gt;)manager didUpdateToLocation:(CLLocation&lt;/em&gt;)newLocation fromLocation:(CLLocation*)oldLocation;//当用户改变位置的时候回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)locationManager:(CLLocationManager&lt;em&gt;)manager didUpdateHeading:(CLLHeading&lt;/em&gt;)newHeading;//当用户改变方向的时候回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)locationManager: (CLLocationManager &lt;em&gt;)manager didFailLoadWithError:(NSError &lt;/em&gt;)error;//当iPhone无法获得当前位置的信息时回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;locationManagerDidPauseLocationUpdates://当停止位置更新回调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;locationManagerDidResumeLocationUpdates: //当继续位置更新回调&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;8-Location地理编码？&quot;&gt;&lt;a href=&quot;#8-Location地理编码？&quot; class=&quot;headerlink&quot; title=&quot;8.Location地理编码？&quot;&gt;&lt;/a&gt;8.Location地理编码？&lt;/h2&gt;&lt;p&gt;1）.CLGeocoder：地理编码器，其中Geo是地理的英文单词Geography的简写。&lt;/p&gt;
&lt;p&gt;2）.使用CLGeocoder可以完成“地理编码”和“反地理编码”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;地理编码：根据给定的地名，获得具体的位置信息（比如经纬度、地址的全称等）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;反地理编码：根据给定的经纬度，获得具体的位置信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3）.CLGeocoder常用属性和方法？&lt;/p&gt;
&lt;p&gt;@property (nonatomic, readonly, getter=isGeocoding) BOOL geocoding;&lt;/p&gt;
&lt;p&gt;-(void)reverseGeocodeLocation:(CLLocation *)location completionHandler:(CLGeocodeCompletionHandler)completionHandler;// reverse geocode requests反地理编码&lt;/p&gt;
&lt;p&gt;-(void)geocodeAddressDictionary:(NSDictionary *)addressDictionary completionHandler:(CLGeocodeCompletionHandler)completionHandler;&lt;/p&gt;
&lt;p&gt;-(void)geocodeAddressString:(NSString *)addressString completionHandler:(CLGeocodeCompletionHandler)completionHandler;//地理编码&lt;/p&gt;
&lt;p&gt;-(void)geocodeAddressString:(NSString &lt;em&gt;)addressString inRegion:(nullable CLRegion &lt;/em&gt;)region completionHandler:(CLGeocodeCompletionHandler)completionHandler;&lt;/p&gt;
&lt;p&gt;-(void)cancelGeocode;&lt;/p&gt;
&lt;p&gt;4）.CLGeocodeCompletionHandler方法&lt;/p&gt;
&lt;p&gt;当地理\反地理编码完成时，就会调用CLGeocodeCompletionHandler，这是一个block，里面与两个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;error ：当编码出错时（比如编码不出具体的信息）有值&lt;/li&gt;
&lt;li&gt;placemarks ：里面装着CLPlacemark对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说明：CLPlacemark的字面意思是地标，封装详细的地址位置信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;地理位置 　　　　@property (nonatomic, readonly) CLLocation *location;　　&lt;/li&gt;
&lt;li&gt;区域　　　　　　 @property (nonatomic, readonly) CLRegion *region;&lt;/li&gt;
&lt;li&gt;详细的地址信息   @property (nonatomic, readonly) NSDictionary *addressDictionary;&lt;/li&gt;
&lt;li&gt;地址名称　　　　@property (nonatomic, readonly) NSString *name;&lt;/li&gt;
&lt;li&gt;城市　　　　　　@property (nonatomic, readonly) NSString *locality;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;本文参考链接&quot;&gt;&lt;a href=&quot;#本文参考链接&quot; class=&quot;headerlink&quot; title=&quot;本文参考链接&quot;&gt;&lt;/a&gt;本文参考链接&lt;/h5&gt;&lt;p&gt;1.&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/CoreLocation/CoreLocation.html#//apple_ref/doc/uid/TP40009497-CH2-SW1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/LocationAwarenessPG/CoreLocation/CoreLocation.html#//apple_ref/doc/uid/TP40009497-CH2-SW1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://stackoverflow.com/questions/19042894/periodic-ios-background-location-updates&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://stackoverflow.com/questions/19042894/periodic-ios-background-location-updates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&quot;http://www.cnblogs.com/wendingding/p/3901527.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/wendingding/p/3901527.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;http://blog.csdn.net/xiaobaismiley/article/details/37576303&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/xiaobaismiley/article/details/37576303&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;http://blog.csdn.net/coolypf/article/details/8569813&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/coolypf/article/details/8569813&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.&lt;a href=&quot;https://www.keakon.net/2011/07/02/WGS84%E5%9D%90%E6%A0%87%E8%BD%AC%E7%81%AB%E6%98%9F%E5%9D%90%E6%A0%87%EF%BC%88iOS%E7%AF%87%EF%BC%89&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.keakon.net/2011/07/02/WGS84%E5%9D%90%E6%A0%87%E8%BD%AC%E7%81%AB%E6%98%9F%E5%9D%90%E6%A0%87%EF%BC%88iOS%E7%AF%87%EF%BC%89&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7.&lt;a href=&quot;http://blog.csdn.net/giswens/article/details/8775183&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/giswens/article/details/8775183&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8.&lt;a href=&quot;http://blog.csdn.net/giswens/article/details/8775121&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/giswens/article/details/8775121&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Location常识？&quot;&gt;&lt;a href=&quot;#1-Location常识？&quot; class=&quot;headerlink&quot; title=&quot;1.Location常识？&quot;&gt;&lt;/a&gt;1.Location常识？&lt;/h2&gt;&lt;p&gt;1)基于GPS/基站/wifi定位&lt;/p&gt;
&lt;p&gt;3种区别是：iOS不像Android系统在定位服务编程时，可以指定采用哪种途径进行定位。iOS的API把底层这些细节屏蔽掉了，开发人员和用户并不知道现在设备是采用哪种方式进行定位的，iOS系统会根据设备的情况和周围的环境，采用一套最佳的解决方案。这个方案是这样的，如果能够接收GPS信息，那么设备优先采用GPS定位，否则采用Wifi或蜂窝基站定位，在Wifi和蜂窝基站之间优先使用Wifi，如果无法连接Wifi才使用蜂窝基站定位。总体来说GPS定位优点是准确、覆盖面广阔，缺点是不能被遮挡（例如：在建筑物里面收不到GPS卫星信号）、GPS开启后比较费电。蜂窝基站不仅误差比较大，而且会耗费用户流量费。而Wifi定位是最经济实惠的。&lt;/p&gt;
&lt;p&gt;2)如果使用基站进行定位,必须要求设备有电话模块&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;2.1 当app被完全关闭时,也可以接收到位置通知,并让app进入到后台处理 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.2 定位精度相比于上面,精度不大,所以耗电小,而且定位更新频率依据基站密度而定&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3)必须开启手机位置服务&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-RunLoop</title>
    <link href="williamliuwen.cn/2016/07/23/AWblog/2016/7/iOS-RunLoop/"/>
    <id>williamliuwen.cn/2016/07/23/AWblog/2016/7/iOS-RunLoop/</id>
    <published>2016-07-23T00:35:55.000Z</published>
    <updated>2016-08-12T22:06:42.000Z</updated>
    
    <content type="html">&lt;hr&gt;
&lt;h4 id=&quot;运行循环本质&quot;&gt;&lt;a href=&quot;#运行循环本质&quot; class=&quot;headerlink&quot; title=&quot;运行循环本质&quot;&gt;&lt;/a&gt;运行循环本质&lt;/h4&gt;&lt;p&gt;1.从字面上看，就是运行循环跑圈&lt;/p&gt;
&lt;p&gt;2.其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;3.循环体的开始需要检测是否有需要处理的事件，如果有则去处&amp;gt; - 理，如果没有则进入睡眠以节省CPU时间&lt;/p&gt;
&lt;h4 id=&quot;FIXME-0-运行循环-概念性的东西有？&quot;&gt;&lt;a href=&quot;#FIXME-0-运行循环-概念性的东西有？&quot; class=&quot;headerlink&quot; title=&quot;FIXME:0.运行循环 概念性的东西有？&quot;&gt;&lt;/a&gt;FIXME:0.运行循环 概念性的东西有？&lt;/h4&gt;&lt;p&gt;概念1【输入源==事件源】&lt;br&gt;具体查看《RunLoop【输入源】》&lt;/p&gt;
&lt;p&gt;概念2【模式】&lt;br&gt;具体查看《RunLoop【模式】》&lt;/p&gt;
&lt;p&gt;概念3【观察者Observer】&lt;br&gt;具体查看《RunLoop【观察者】》&lt;/p&gt;
&lt;!--more--&gt;
&lt;h4 id=&quot;FIXME-1-运行循环-为什么要使用运行循环&quot;&gt;&lt;a href=&quot;#FIXME-1-运行循环-为什么要使用运行循环&quot; class=&quot;headerlink&quot; title=&quot;FIXME:1.运行循环 为什么要使用运行循环&quot;&gt;&lt;/a&gt;FIXME:1.运行循环 为什么要使用运行循环&lt;/h4&gt;&lt;p&gt;1.我们思考一下：程序为什么可以处理用户的各种事件，而且可以保证程序不退出？答案：就是因为程序里面有个系统的默认运行循环，所以能保证程序不退出，并且处理用户的各种事件&lt;/p&gt;
&lt;p&gt;2.想要了解为什么要使用运行循环，我们可以从使用运行循环的目的来了解，使用了运行循环我们可以：&lt;br&gt;a. 保证程序不退出 ;&lt;br&gt;b. 负责处理输入事件;&lt;br&gt;c. 如果没有事件发生，会让程序进入休眠状态。&lt;br&gt;从上面可以得出结论，为什么要使用运行循环，因为这是一个APP的基本，没有运行循环，就没有APP的正常运行。&lt;/p&gt;
&lt;p&gt;3.通过上面的了解我们可以总结运行循环的优点：有事情就做事情，没事情就休息；优点：节省CPU资源、提高程序性能；&lt;/p&gt;
&lt;h4 id=&quot;FIXME-2-运行循环-程序里哪里存在运行循环&quot;&gt;&lt;a href=&quot;#FIXME-2-运行循环-程序里哪里存在运行循环&quot; class=&quot;headerlink&quot; title=&quot;FIXME:2.运行循环 程序里哪里存在运行循环&quot;&gt;&lt;/a&gt;FIXME:2.运行循环 程序里哪里存在运行循环&lt;/h4&gt;&lt;p&gt;1.【系统默认 运行循环】系统默认就是一个运行循环，可以保证程序不死掉；系统默认运行循环在主线程&lt;/p&gt;
&lt;h4 id=&quot;FIXME-3-运行循环-与线程的关系&quot;&gt;&lt;a href=&quot;#FIXME-3-运行循环-与线程的关系&quot; class=&quot;headerlink&quot; title=&quot;FIXME:3.运行循环 与线程的关系&quot;&gt;&lt;/a&gt;FIXME:3.运行循环 与线程的关系&lt;/h4&gt;&lt;p&gt;1.每一个线程内部都有一个消息循环。只有主线程的消息循环默认开启,子线程的消息循环默认不开启，一个运行循环对应着一条唯一的线程，如何让子线程不死 ，给这条子线程开启一个运行循环，子线程的runloop需要手动创建,需要手动开启&lt;/p&gt;
&lt;p&gt;2.线程在执行中的休眠和激活就是由RunLoop对象进行管理的&lt;/p&gt;
&lt;p&gt;3.RunLoop是用来管理线程的&lt;/p&gt;
&lt;p&gt;4.每一个线程都有一个RunLoop对象。可以通过具体的方法去获得&lt;/p&gt;
&lt;p&gt;5.但是需要注意：虽然每一个线程都可以获取RunLoop对象，但是并不是每一个线程中都有实例对象，我们可以这样理解：如果我们不获取RunLoop，这个RunLoop就不存在，我们获取时，如果不存在，就会去创建。在主线程中，这个MainRunLoop是默认创建并运行激活的&lt;/p&gt;
&lt;p&gt;6.每条线程都有唯一的一个与之对应的RunLoop对象&lt;/p&gt;
&lt;h4 id=&quot;FIXME-4-运行循环-生命周期&quot;&gt;&lt;a href=&quot;#FIXME-4-运行循环-生命周期&quot; class=&quot;headerlink&quot; title=&quot;FIXME:4.运行循环 生命周期&quot;&gt;&lt;/a&gt;FIXME:4.运行循环 生命周期&lt;/h4&gt;&lt;p&gt;1.运行循环的生命周期：在第一次获取时创建，在线程结束时销毁&lt;/p&gt;
&lt;h4 id=&quot;FIXME-5-运行循环-基本运行流程&quot;&gt;&lt;a href=&quot;#FIXME-5-运行循环-基本运行流程&quot; class=&quot;headerlink&quot; title=&quot;FIXME:5.运行循环 基本运行流程&quot;&gt;&lt;/a&gt;FIXME:5.运行循环 基本运行流程&lt;/h4&gt;&lt;p&gt;1.创建消息（即输入源）；&lt;/p&gt;
&lt;p&gt;2.指定该事件（源）在循环中运行的模式，并加入循环；&lt;/p&gt;
&lt;p&gt;3.当事件的模式与消息循环的模式匹配的时候，消息才会运行。&lt;/p&gt;
&lt;p&gt;4.运行逻辑总结：一个线程对应一个runLoop,主线程的runloop是程序一启动,默认就创建一个runloop,创建好了之后就会给它添加一些默认的模式,每个模式里面会有很多的 source /timer/observer ,添加好这些模式后,observer就会监听主线程的runloop,进入runloop后,就开始处理事件,先处理timer,再处理source0,source0处理完之后再处理source1,当把这些所有的事件反复的处理完之后,如果没有事件了,那么runloop就会进入睡眠状态,当用户又触发了新的事件,就会唤醒runloop,唤醒runloop后回到第二步,重新处理新的timer,新的source0,新的source1,处理完后就睡眠,一直反复,当我们把程序关闭或者强退,这个时候observer就会监听都runloop退出了.&lt;/p&gt;
&lt;h4 id=&quot;FIXME-6-运行循环-API&quot;&gt;&lt;a href=&quot;#FIXME-6-运行循环-API&quot; class=&quot;headerlink&quot; title=&quot;FIXME:6.运行循环 API&quot;&gt;&lt;/a&gt;FIXME:6.运行循环 API&lt;/h4&gt;&lt;p&gt;1.NSRunloop&lt;/p&gt;
&lt;p&gt;2.CFRunLoopRef&lt;/p&gt;
&lt;p&gt;3.两种API的区别1：NSRunloop线程不安全，CFRunLoopRef线程安全；NSRunLoop是Cocoa框架中的类，与之对应的是在Core Fundation中有一个CFRunLoopRef类。这两者的区别是前者不是线程安全的，而CFRunLoopRef是线程安全的。所以：NSRunloop不能调用其他线程的方法.The NSRunLoop class is generally not considered to be thread-safe and its methods should only be called within the context of the current thread. You should never try to call the methods of an NSRunLoop object running in a different thread, as doing so might cause unexpected results.&lt;/p&gt;
&lt;p&gt;4.两种API的区别2：CFRunLoopRef创建一个timer必须添加到runloop 才会执行,添加的时候要指定模式 defaurce模式 ,不对程序做任何操作 timer就会后台运行 ,当我进行操作的时候runloop模式就会从默认模式切换到其他模式,假如说我操作scrollerView 它就会从default模式切换到tracking模式。而roonloop 同一时刻只能执行一种模式.&lt;/p&gt;
&lt;p&gt;5.NSRunLoop是基于CFRunLoopRef的一层OC包装，提供了面向对象的 API，但是这些 API 不是线程安全的。所以要了解RunLoop内部结构，需要多研究CFRunLoopRef层面的API（Core Foundation层面）&lt;/p&gt;
&lt;h4 id=&quot;FIXME-7-运行循环-启动&quot;&gt;&lt;a href=&quot;#FIXME-7-运行循环-启动&quot; class=&quot;headerlink&quot; title=&quot;FIXME:7.运行循环 启动&quot;&gt;&lt;/a&gt;FIXME:7.运行循环 启动&lt;/h4&gt;&lt;p&gt;启动的三种方式：&lt;/p&gt;
&lt;p&gt;1.无条件的—-无条件的进入Runloop是最简单的方法，但也最不推荐使用的。因为这样会使你的线程处在一个永久的循环中，这会让你对Runloop本身的控制很少。你可以添加或删除输入源和定时器，但是退出Runloop的唯一方法是杀死它。没有任何办法可以让这Runloop运行在自定义模式下。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] run];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.设置超时时间—-替代无条件进入Runloop更好的办法是用预设超时时间来运行Runloop，这样Runloop运作直到某一事件到达或者规定的时间已经到期。如果是事件到达，消息会被传递给相应的处理程序来处理，然后Runloop退出。你可以重新启动Runloop来等待下一事件。如果是规定时间到期了，你只需简单的重启Runloop或使用此段时间来做任何的其他工作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]]; 2 秒钟之后结束&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3.特定的模式—-除了超时机制，你也可以使用特定的模式来运行你的Runloop。模式和超时不是互斥的，他们可以在启动RunLoop的时候同时使用。模式限制了可以传递事件给Runloop的输入源的类型。暂停当前处理的流程，转而处理其他输入源，当date设置为&lt;a href=&quot;将来，基本不会到达的时间&quot;&gt;NSDate distantFuture&lt;/a&gt;，所以除非处理其他输入源结束，否则永不退出处理暂停的当前处理的流程&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;FIXME-8-运行循环-结束&quot;&gt;&lt;a href=&quot;#FIXME-8-运行循环-结束&quot; class=&quot;headerlink&quot; title=&quot;FIXME:8.运行循环 结束&quot;&gt;&lt;/a&gt;FIXME:8.运行循环 结束&lt;/h4&gt;&lt;p&gt;结束的三种方式：&lt;/p&gt;
&lt;p&gt;1.给RunLoop设置超时时间&lt;/p&gt;
&lt;p&gt;2.通知RunLoop停止—-如果可以配置的话，推荐使用第一种方法。指定一个超时时间可以使RunLoop退出前完成所有正常操作，包括发送消息给RunLoop观察者。&lt;/p&gt;
&lt;p&gt;3.使用CFRunLoopStop来显式的停止RunLoop和使用超时时间产生的结果相似。RunLoop把所有剩余的通知发送出去再退出。与设置超时的不同的是你可以在无条件启动的RunLoop里面使用该技术。&lt;/p&gt;
&lt;h4 id=&quot;FIXME-9-运行循环-添加输入源&quot;&gt;&lt;a href=&quot;#FIXME-9-运行循环-添加输入源&quot; class=&quot;headerlink&quot; title=&quot;FIXME:9.运行循环 添加输入源&quot;&gt;&lt;/a&gt;FIXME:9.运行循环 添加输入源&lt;/h4&gt;&lt;p&gt;具体查看《NSRunLoop【例子&lt;em&gt;输入源&lt;/em&gt;】》&lt;/p&gt;
&lt;h4 id=&quot;FIXME-10-运行循环-移除输入源&quot;&gt;&lt;a href=&quot;#FIXME-10-运行循环-移除输入源&quot; class=&quot;headerlink&quot; title=&quot;FIXME:10.运行循环 移除输入源&quot;&gt;&lt;/a&gt;FIXME:10.运行循环 移除输入源&lt;/h4&gt;&lt;p&gt;1.输入源被注册到RunLoop中时会有方法进行remove。但是定时器没有remove，但是它的invalidate方法可以将其从RunLoop中移除。invalidate是重要的也是唯一的将定时器从RunLoop中注销的方法，所以如果我们创建了定时器，就一定要再不适用的时候调用invalidate方法。&lt;/p&gt;
&lt;p&gt;2.自动释放池,什么时候创建和释放 ?&lt;br&gt;(1)第一次创建:是在runloop进入的时候创建 对应的状态 = KCFRunLoopEntry&lt;br&gt;(2)最后一个退出,是在runloop退出的时候 对应的状态 = KCFRunLoopExit&lt;br&gt;(3)其他的创建和释放&lt;br&gt;每次睡觉的时候会释放前自动释放池,再创建一个新的&lt;br&gt;即将进入睡眠的时候,先释放上一次创建的自动释放池,然后再创建一个新的释放池&lt;/p&gt;
&lt;h4 id=&quot;FIXME-11-运行循环-能运行的关键&quot;&gt;&lt;a href=&quot;#FIXME-11-运行循环-能运行的关键&quot; class=&quot;headerlink&quot; title=&quot;FIXME:11.运行循环 能运行的关键&quot;&gt;&lt;/a&gt;FIXME:11.运行循环 能运行的关键&lt;/h4&gt;&lt;p&gt;1.每次运行一个RunLoop，你指定（显式或隐式）RunLoop的运行模式。当相应的模式传递给RunLoop时，只有与该模式对应的Input Source才被监控并允许RunLoop对事件进行处理（与此类似，也只有与该模式对应的Observers才会被通知）&lt;/p&gt;
&lt;p&gt;2.上面的对应关系是：&lt;/p&gt;
&lt;p&gt;RunLoop—-模式—-&lt;br&gt;模式—-Input Sources&lt;br&gt;模式—-Observers&lt;/p&gt;
&lt;h4 id=&quot;FIXME-12-运行循环-可以对运行循环做的操作&quot;&gt;&lt;a href=&quot;#FIXME-12-运行循环-可以对运行循环做的操作&quot; class=&quot;headerlink&quot; title=&quot;FIXME:12.运行循环 可以对运行循环做的操作&quot;&gt;&lt;/a&gt;FIXME:12.运行循环 可以对运行循环做的操作&lt;/h4&gt;&lt;p&gt;1.添加输入源；添加定时源；添加观察者；&lt;/p&gt;
&lt;h4 id=&quot;FIXME-13-运行循环-获得RunLoop对象&quot;&gt;&lt;a href=&quot;#FIXME-13-运行循环-获得RunLoop对象&quot; class=&quot;headerlink&quot; title=&quot;FIXME:13.运行循环 获得RunLoop对象&quot;&gt;&lt;/a&gt;FIXME:13.运行循环 获得RunLoop对象&lt;/h4&gt;&lt;p&gt;Foundation&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[NSRunLoop currentRunLoop];   // 获得当前线程的RunLoop对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[NSRunLoop mainRunLoop];      // 获得主线程的RunLoop对象&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Core Foundation&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CFRunLoopGetCurrent();       // 获得当前线程的RunLoop对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CFRunLoopGetMain();          // 获得主线程的RunLoop对象&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;FIXME-13-RunLoop是否有效的关键是？&quot;&gt;&lt;a href=&quot;#FIXME-13-RunLoop是否有效的关键是？&quot; class=&quot;headerlink&quot; title=&quot;FIXME:13.RunLoop是否有效的关键是？&quot;&gt;&lt;/a&gt;FIXME:13.RunLoop是否有效的关键是？&lt;/h4&gt;&lt;p&gt;1.关键是有没有事件源或者定时源；&lt;/p&gt;
&lt;h2 id=&quot;RunLoop模式&quot;&gt;&lt;a href=&quot;#RunLoop模式&quot; class=&quot;headerlink&quot; title=&quot;RunLoop模式&quot;&gt;&lt;/a&gt;RunLoop模式&lt;/h2&gt;&lt;p&gt;1.NS开头(Cocoa)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSDefaultRunLoopMode 默认模式（最常用的循环模式） 默认Mode, 通常主线程在这个模式下运行处理modal panels（The mode to deal with input sources other than NSConnection objects. This is the most commonly used run-loop mode. Available in iOS 2.0 and later.）,DefaultMode 是 App 平时所处的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;NSEventTrackingRunLoopMode 此模式下用于处理窗口事件,鼠标事件等,如组件拖动输入源 UITrackingRunLoopModes 不处理定时事件；TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;NSRunLoopCommonModes 普通模式（一组模式的集合,包括NSDefaultRunLoopMode和UITrackingRunLoopMode）（Objects added to a run loop using this value as the mode are monitored by all run loop modes that have been declared as a member of the set of “common” modes; see the description of CFRunLoopAddCommonMode for details.）；哪些mode默认久标记为”Common”属性：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。    此模式用于配置”组模式”，一个输入源与此模式关联，则输入源与组中的所有模式相关联。这是一组可配置的通用模式。将input sources与该模式关联则同时也将input sources与该组中的其它模式进行了关联。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;NSConnectionReplyMode 此模式用于处理NSConnection的回调事件,：处理NSConnection事件，属于系统内部，用户基本不用&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;NSModalPanelRunLoopMode 模态模式，此模式下，RunLoop只对处理模态相关事件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.CF开头(Core Foundation)&lt;/p&gt;
&lt;p&gt;1）系统默认注册了5中mode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kCFRunLoopDefaultMode App的默认Mode，通常主线程是在这个Mode下运行；缺省情况下，将包含所有操作，并且大多数情况下都会使用此模式,几乎包括所有输入源(除NSConnection),对应NSDefaultRunLoopMode&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;UITrackingRunLoopMode 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;UIInitializationRunLoopMode 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;GSEventReceiveRunLoopMode 接受系统事件的内部 Mode，通常用不到&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;kCFRunLoopCommonModes 这是一个占位用的Mode，不是一种真正的Mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.RunLoop模式介绍&lt;/p&gt;
&lt;p&gt;1）RunLoopMode是一个集合，包括监听：事件源，定时器，以及需通知的RunLoop observers&lt;br&gt;2）CFRunloopModeRef代表着Runloop的运行模式&lt;br&gt;3）一个Runloop中可以有多个mode,一个mode里面又可以有多个source\observer\timer等等&lt;br&gt;4）每次runloop启动的时候，只能指定一个mode,这个mode被称为该Runloop的当前mode&lt;br&gt;5）如果需要切换mode,只能先退出当前Runloop,再重新指定一个mode进入；RunLoop在某一时刻只能在一种模式下运行, 更换模式时需要暂停当前的Loop, 然后重启新的Loop.&lt;br&gt;6）这样做主要是为了分割不同组的定时器等，让他们相互之间不受影响&lt;/p&gt;
&lt;p&gt;4.模式切换&lt;/p&gt;
&lt;p&gt;1）NSDefaultRunLoopMode 切换为 NSEventTrackingRunLoopMode&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;当设置事件模式为NSDefaultRunLoopMode 时，拖动UITextView界面,定时源停止运行；当停止拖动，定时源又继续运行;当设置事件模式为NSRunLoopCommonModes 时，拖动UITextView界面,定时源持续运行不受影响。此外，当设置事件模式为NSRunLoopCommonModes 时，未拖动UITextView界面时，消息循环的模式为kCFRunLoopDefaultMode ，当拖动UITextView界面时，消息循环的模式自动变为UITrackingRunLoopMode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）模式切换例2&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用了scheduledTimer返回的定时器，已经自动被添加到当前runLoop中，而且是NSDefaultRunLoopMode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 修改模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当你在滑动ScrollView的时候上面的timer会失效, 原因是Timer是默认加在NSDefalutRunLoopMode上的, 而滑动ScrollView后系统把RunLoop切换为UITrackingRunLoopMode, 所以timer就不会执行了. 解决方法是把该Timer加到NSRunLoopCommonModes下, 这样即使滑动ScrollView也不会影响timer了.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3) 模式切换例3&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;另外还有一个trick是当tableview的cell从网络异步加载图片, 加载完成后在主线程刷新显示图片, 这时滑动tableview会造成卡顿. 通常的思路是tableview滑动的时候延迟加载图片, 等停止滑动时再显示图片. 这里我们可以通过RunLoop来实现.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.cellImageView performSelector:@sector(setImage:)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;withObject:downloadedImage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;afterDelay:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;inModes:@[NSDefaultRunLoopMode]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当NSRunLoop为NSDefaultRunLoopMode的时候tableview肯定停止滑动了, why? 因为如果还在滑动中, RunLoop的mode应该是UITrackingRunLoopMode.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4)让一个事件同时在两个mode都有回调方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;方式1:&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 定时器只运行在NSDefaultRunLoopMode下，一旦RunLoop进入其他模式，这个定时器就不会工作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 定时器只运行在UITrackingRunLoopMode下，一旦RunLoop进入其他模式，这个定时器就不会工作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] addTimer:timer forMode:UITrackingRunLoopMode];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;方式2：&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 定时器会跑在标记为common modes的模式下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 标记为common modes的模式：UITrackingRunLoopMode和NSDefaultRunLoopMode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;RunLoop观察者&quot;&gt;&lt;a href=&quot;#RunLoop观察者&quot; class=&quot;headerlink&quot; title=&quot;RunLoop观察者&quot;&gt;&lt;/a&gt;RunLoop观察者&lt;/h2&gt;&lt;p&gt;1.观察者状态&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCFRunLoopEntry = (1UL &amp;lt;&amp;lt; 0),         //即将进入Runloop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCFRunLoopBeforeTimers = (1UL &amp;lt;&amp;lt; 1),  //即将处理NSTimer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCFRunLoopBeforeSources = (1UL &amp;lt;&amp;lt; 2), //即将处理Sources&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCFRunLoopBeforeWaiting = (1UL &amp;lt;&amp;lt; 5), //即将进入休眠&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCFRunLoopAfterWaiting = (1UL &amp;lt;&amp;lt; 6),  //刚从休眠中唤醒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCFRunLoopExit = (1UL &amp;lt;&amp;lt; 7),          //即将退出runloop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kCFRunLoopAllActivities = 0x0FFFFFFFU //所有状态改变&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一个参数:用于分配该observer对象的内存 CFAllocatorGetDefault&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个参数:用以设置该observer所要关注的的事件 kCFRunLoopAllActivities&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个参数:用于标识该observer是在第一次进入run loop时执行, 还是每次进入run loop处理时均执行 YES&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第四个参数:用于设置该observer的优先级 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第五个参数: observer监听到事件时的回调block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;switch(activity)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case kCFRunLoopEntry:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;即将进入loop&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case kCFRunLoopBeforeTimers:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;即将处理timers&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case kCFRunLoopBeforeSources:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;即将处理sources&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case kCFRunLoopBeforeWaiting:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;即将进入休眠&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case kCFRunLoopAfterWaiting:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;刚从休眠中唤醒&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case kCFRunLoopExit:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;即将退出loop&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.参数解析&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CFRunLoopAddObserver(CFRunLoopGetMain(), observer, kCFRunLoopDefaultMode);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一个参数: 给哪个RunLoop添加监听&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个参数: 需要添加的Observer对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个参数: 在哪种模式下监听&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.释放观察者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CFRelease(observer);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4.添加观察者过程&lt;/p&gt;
&lt;p&gt;1）创建一个观察者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//创建一个runloop监听者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities,YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@”监听RunLoop状态改变—%zd”,activity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2）添加创建的观察者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CFRunLoopAddObserver(CFRunLoopGetCurrent(),observer,kCFRunLoopDefaultMode);// 添加观察者：监听RunLoop的状态&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3）释放创建的观察者&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;CFRelease(observer);//释放&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5.RunLoop观察者介绍&lt;/p&gt;
&lt;p&gt;1）CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变&lt;/p&gt;
&lt;p&gt;2）Observer是监听RunLoop状态的，CoreFunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。&lt;/p&gt;
&lt;p&gt;3）线程除了处理输入源，RunLoop也会生成关于Run Loop行为的通知（notification）。RunLoop观察者（Run-Loop Observers）可以收到这些通知，并在线程上面使用他们来作额外的处理；如果RunLoop没有任何源需要监视的话，它会在你启动之际立马退出。&lt;/p&gt;
&lt;h2 id=&quot;RunLoop输入源&quot;&gt;&lt;a href=&quot;#RunLoop输入源&quot; class=&quot;headerlink&quot; title=&quot;RunLoop输入源&quot;&gt;&lt;/a&gt;RunLoop输入源&lt;/h2&gt;&lt;p&gt;1.RunLoop能处理的事件：输入源（事件源）、定时源 ;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;输入源也就是用户的各种事件，如触摸事件、定时器事件NSTimer、选择器事件selector;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;输入源是为了接收消息；当为一个长期存活的现场配置runloop时，至少添加一个input source去接收消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CFRunLoopSourceRef 是事件产生的地方&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.输入源（事件源）&lt;/p&gt;
&lt;p&gt;1）一般用来处理异步事件的；&lt;/p&gt;
&lt;p&gt;2）两种分法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;旧：按照苹果官方文档进行划分的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;新：基于函数的调用栈来进行划分的（source0和source1）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3）旧：按照苹果官方文档进行划分的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Cocoa Perform Selector Sources（performSelector源）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Custom Input Sources（自定义源）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Port-Based Sources（基于端口Mach port的源）通过内核和其他线程通信，接收、分发系统事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4) 新：基于函数的调用栈来进行划分的（source0和source1）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;source0是非基于端口的,是用户自己手动触发的操作,比如触摸滑动等操作.只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Source1是系统内部的一些端口触发的事件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.定时源&lt;/p&gt;
&lt;p&gt;1）一般用来处理同步事件的&lt;/p&gt;
&lt;p&gt;2）定时源即NSTimer（add timer）&lt;/p&gt;
&lt;p&gt;3) CFRunLoopTimerRef是基于时间的触发器&lt;/p&gt;
&lt;p&gt;4) CFRunLoopTimerRef基本上说的就是NSTimer，它受RunLoop的Mode影响&lt;/p&gt;
&lt;p&gt;5) GCD的定时器不受RunLoop的Mode影响&lt;/p&gt;
&lt;p&gt;6）一个mode里面可以添加多个NSTimer，也就是说以后当创建NSTimer的时候，可以指定它是在什么模式下运行的。&lt;/p&gt;
&lt;p&gt;4.performSelector源&lt;/p&gt;
&lt;p&gt;1) 当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。&lt;/p&gt;
&lt;p&gt;2) 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。&lt;/p&gt;
&lt;p&gt;3) performSelector应用：可以让某些事件（行为、任务）在特定模式下执行; 有时候图片比较大，渲染到屏幕耗费时间，会造成界面卡顿，可以让图片在UIScrollView滚动完之后执行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@&amp;quot;placeholder&amp;quot;] afterDelay:2 inModes:@[NSDefaultRunLoopMode]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5.自定义源&lt;/p&gt;
&lt;p&gt;6.基于端口源&lt;/p&gt;
&lt;h2 id=&quot;RunLoop类&quot;&gt;&lt;a href=&quot;#RunLoop类&quot; class=&quot;headerlink&quot; title=&quot;RunLoop类&quot;&gt;&lt;/a&gt;RunLoop类&lt;/h2&gt;&lt;p&gt;1.五个类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.CFRunLoopRef&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.CFRunLoopModeRef      代表RunLoop的运行模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3.CFRunLoopSourceRef&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4.CFRunLoopTimerRef&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5.CFRunLoopObserverRef&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.CFRunLoopModeRef类&lt;/p&gt;
&lt;p&gt;1）参照RunLoop模式&lt;/p&gt;
&lt;p&gt;3.CFRunLoopSourceRef类&lt;/p&gt;
&lt;p&gt;1）参照RunLoop输入源&lt;/p&gt;
&lt;p&gt;4.CFRunLoopTimerRef类&lt;/p&gt;
&lt;p&gt;1）参照RunLoop输入源&lt;/p&gt;
&lt;p&gt;5.CFRunLoopObserverRef类&lt;/p&gt;
&lt;p&gt;1）参照RunLoop观察者&lt;/p&gt;
&lt;h2 id=&quot;RunLoop属性和方法&quot;&gt;&lt;a href=&quot;#RunLoop属性和方法&quot; class=&quot;headerlink&quot; title=&quot;RunLoop属性和方法&quot;&gt;&lt;/a&gt;RunLoop属性和方法&lt;/h2&gt;&lt;p&gt;1.获取主线程的RunLoop，主线程下就没必要调用[runLoop run]了, 因为它本来就是一直run的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSRunLoop * runloop = [NSRunLoop mainRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CFRunLoopRef runloop = CFRunLoopGetMain();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.获取当前线程的RunLoop:有的话就直接获取，没有的话就自动创建&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSRunLoop * myRunLoop = [NSRunLoop currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.将定时器添加到runloop中&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-（void）addTimer:(NSTimer *)timer forMode:(NSString *)mode;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4.添加输入源端口到runloop中，NSPort对象可以理解为详细的载体，会传递消息与其代理。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)addPort:(NSPort *)aPort forMode:(NSString *)mode;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;5.将某个输入源端口移除&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)removePort:(NSPort *)aPort forMode:(NSString *)mode;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;6.到某个时间点运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)runUntilDate:(NSDate *)limitDate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;7.在某个期限前运行&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;8.在某个时间期限前接收相应&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-(void)aceptInputForMode:(NSString *)mode beforeDate:(NSDate *)limitDate;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;9.子线程开启消息循环&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法1&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 开启消息循环 使用run方法后无法停止消息循环。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] run];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法2&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 指定循环运行时间&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;方法3&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BOOL shouldKeepRunning = YES;    // global设置为global变量，可控制该消息循环的开闭；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSRunLoop *theRL = [NSRunLoop currentRunLoop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;while (shouldKeepRunning &amp;amp;&amp;amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h6 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h6&gt;&lt;p&gt;1.&lt;a href=&quot;http://blog.csdn.net/wjsxiaoweige/article/details/38318733&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/wjsxiaoweige/article/details/38318733&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://blog.ibireme.com/2015/05/18/runloop/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.ibireme.com/2015/05/18/runloop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&quot;http://blog.csdn.net/yang__xz/article/details/50813404&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/yang__xz/article/details/50813404&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;http://blog.chinaunix.net/uid-24862988-id-3408565.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.chinaunix.net/uid-24862988-id-3408565.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;http://my.oschina.net/u/816791/blog/387568&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://my.oschina.net/u/816791/blog/387568&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.&lt;a href=&quot;http://blog.csdn.net/ios_che/article/details/8252800&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/ios_che/article/details/8252800&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7.&lt;a href=&quot;http://www.tuicool.com/articles/uaaei2u&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.tuicool.com/articles/uaaei2u&lt;/a&gt; 比较好&lt;/p&gt;
&lt;p&gt;8.&lt;a href=&quot;http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yangchao0033.github.io/blog/2016/01/06/runloopshen-du-tan-jiu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9.&lt;a href=&quot;http://yangchao0033.github.io/blog/2016/01/18/runloop-5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://yangchao0033.github.io/blog/2016/01/18/runloop-5/&lt;/a&gt; 理解&lt;/p&gt;
&lt;p&gt;10.&lt;a href=&quot;http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-er-:ru-he-pei-zhi-run-loop-sources/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://chun.tips/blog/2014/10/20/zou-jin-run-loopde-shi-jie-er-:ru-he-pei-zhi-run-loop-sources/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11.&lt;a href=&quot;https://github.com/yechunjun/RunLoopDemo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/yechunjun/RunLoopDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;12.&lt;a href=&quot;http://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html&lt;/a&gt; 不错&lt;/p&gt;
&lt;p&gt;13.&lt;a href=&quot;https://blog.cnbluebox.com/blog/2014/07/01/cocoashen-ru-xue-xi-nsoperationqueuehe-nsoperationyuan-li-he-shi-yong/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.cnbluebox.com/blog/2014/07/01/cocoashen-ru-xue-xi-nsoperationqueuehe-nsoperationyuan-li-he-shi-yong/&lt;/a&gt;  比较容易理解&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h4 id=&quot;运行循环本质&quot;&gt;&lt;a href=&quot;#运行循环本质&quot; class=&quot;headerlink&quot; title=&quot;运行循环本质&quot;&gt;&lt;/a&gt;运行循环本质&lt;/h4&gt;&lt;p&gt;1.从字面上看，就是运行循环跑圈&lt;/p&gt;
&lt;p&gt;2.其实它内部就是do-while循环，在这个循环内部不断地处理各种任务（比如Source、Timer、Observer）&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-数据持久化</title>
    <link href="williamliuwen.cn/2016/07/12/AWblog/2016/7/iOS-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>williamliuwen.cn/2016/07/12/AWblog/2016/7/iOS-数据持久化/</id>
    <published>2016-07-12T12:48:41.000Z</published>
    <updated>2016-08-13T13:35:38.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-RunTime</title>
    <link href="williamliuwen.cn/2016/07/09/AWblog/2016/7/iOS-RunTime/"/>
    <id>williamliuwen.cn/2016/07/09/AWblog/2016/7/iOS-RunTime/</id>
    <published>2016-07-08T22:02:46.000Z</published>
    <updated>2016-08-13T13:36:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;runtime常用方法&quot;&gt;&lt;a href=&quot;#runtime常用方法&quot; class=&quot;headerlink&quot; title=&quot;runtime常用方法&quot;&gt;&lt;/a&gt;runtime常用方法&lt;/h2&gt;&lt;p&gt;1.类结构：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_class &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class isa  OBJC_ISA_AVAILABILITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if !__OBJC2__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class super_class                       OBJC2_UNAVAILABLE;  // 父类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char *name                        OBJC2_UNAVAILABLE;  // 类名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_object &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class isa  OBJC_ISA_AVAILABILITY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.类实例结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_object *id;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.类实例结构_常用函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取类的类名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * class_getName ( Class cls );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取类的父类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class class_getSuperclass ( Class cls );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 判断给定的Class是否是一个元类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL class_isMetaClass ( Class cls );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取实例大小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size_t class_getInstanceSize ( Class cls );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取类中指定名称实例成员变量的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ivar class_getInstanceVariable ( Class cls, const char *name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取类成员变量的信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ivar class_getClassVariable ( Class cls, const char *name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 添加成员变量,方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取整个成员变量列表 ，后续必须使用free释放Ivar这个数组对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取指定的属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t class_getProperty ( Class cls, const char *name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取属性列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 为类添加属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 替换类的属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4.类方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_method *Method;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_method &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *method_types              OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP method_imp                  OBJC2_UNAVAILABLE;  // 方法实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5.类方法_常用函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 添加方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取实例方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Method class_getInstanceMethod ( Class cls, SEL name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取类方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Method class_getClassMethod ( Class cls, SEL name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取所有方法的数组&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Method * class_copyMethodList ( Class cls, unsigned int *outCount );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 替代方法的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 返回方法的具体实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP class_getMethodImplementation ( Class cls, SEL name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP class_getMethodImplementation_stret ( Class cls, SEL name );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 类实例是否响应指定的selector&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL class_respondsToSelector ( Class cls, SEL sel );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;6.实例方法_常用函数&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用指定方法的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id method_invoke ( id receiver, Method m, ... );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用返回一个数据结构的方法的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void method_invoke_stret ( id receiver, Method m, ... );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取方法名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SEL method_getName ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 返回方法的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP method_getImplementation ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取描述方法参数和返回值类型的字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * method_getTypeEncoding ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取方法的返回值类型的字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char * method_copyReturnType ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取方法的指定位置参数的类型字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char * method_copyArgumentType ( Method m, unsigned int index );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 通过引用返回方法的返回值类型字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void method_getReturnType ( Method m, char *dst, size_t dst_len );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 返回方法的参数的个数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsigned int method_getNumberOfArguments ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 通过引用返回方法指定位置参数的类型字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 返回指定方法的方法描述结构体&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_method_description * method_getDescription ( Method m );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 设置方法的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IMP method_setImplementation ( Method m, IMP imp );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 交换两个方法的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void method_exchangeImplementations ( Method m1, Method m2 );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//函数调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(receiver, selector)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_msgSend(receiver, selector, arg1, arg2, ...)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;7.方法选择器&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 返回给定选择器指定的方法的名称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * sel_getName ( SEL sel );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SEL sel_registerName ( const char *str );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在Objective-C Runtime系统中注册一个方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SEL sel_getUid ( const char *str );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 比较两个选择器&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL sel_isEqual ( SEL lhs, SEL rhs );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;8.动态创建类&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 创建一个新类和元类 extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 销毁一个类及其相关联的类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void objc_disposeClassPair ( Class cls );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在应用中注册由objc_allocateClassPair创建的类&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void objc_registerClassPair ( Class cls );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 例子1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class cls = objc_allocateClassPair(MyClass.class, &amp;quot;MySubClass&amp;quot;, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, &amp;quot;v@:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, &amp;quot;v@:&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addIvar(cls, &amp;quot;_ivar1&amp;quot;, sizeof(NSString *), log(sizeof(NSString *)), &amp;quot;i&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_attribute_t type = &amp;#123;&amp;quot;T&amp;quot;, &amp;quot;@\&amp;quot;NSString\&amp;quot;&amp;quot;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_attribute_t ownership = &amp;#123; &amp;quot;C&amp;quot;, &amp;quot;&amp;quot; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_attribute_t backingivar = &amp;#123; &amp;quot;V&amp;quot;, &amp;quot;_ivar1&amp;quot;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_attribute_t attrs[] = &amp;#123;type, ownership, backingivar&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class_addProperty(cls, &amp;quot;property2&amp;quot;, attrs, 3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_registerClassPair(cls);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id instance = [[cls alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[instance performSelector:@selector(submethod1)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[instance performSelector:@selector(method1)];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;9.动态创建对象&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 创建类实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id class_createInstance ( Class cls, size_t extraBytes );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在指定位置创建类实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id objc_constructInstance ( Class cls, void *bytes );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 销毁类实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void * objc_destructInstance ( id obj );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 例子1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id theObject = class_createInstance(NSString.class, sizeof(unsigned));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id str1 = [theObject init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, [str1 class]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id str2 = [[NSString alloc] initWithString:@&amp;quot;test&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, [str2 class]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;10.成员变量、属性&lt;/p&gt;
&lt;p&gt;Ivar 结构：Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针，其定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_ivar *Ivar;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_ivar &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *ivar_name                 OBJC2_UNAVAILABLE;  // 变量名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *ivar_type                 OBJC2_UNAVAILABLE;  // 变量类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int ivar_offset                 OBJC2_UNAVAILABLE;  // 基地址偏移字节&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#ifdef __LP64__&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int space                       OBJC2_UNAVAILABLE;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;11.objc_property_t 属性结构&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct objc_property *objc_property_t;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef struct &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char *name;           // 特性名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char *value;          // 特性值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; objc_property_attribute_t;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;12.常用方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取成员变量名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * ivar_getName ( Ivar v );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取成员变量类型编码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * ivar_getTypeEncoding ( Ivar v );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取成员变量的偏移量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ptrdiff_t ivar_getOffset ( Ivar v );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 设置关联对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取关联对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id objc_getAssociatedObject ( id object, const void *key );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 移除关联对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void objc_removeAssociatedObjects ( id object );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取属性名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * property_getName ( objc_property_t property );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取属性特性描述字符串&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * property_getAttributes ( objc_property_t property );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取属性中指定的特性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 获取属性的特性列表&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;runtime常用方法&quot;&gt;&lt;a href=&quot;#runtime常用方法&quot; class=&quot;headerlink&quot; title=&quot;runtime常用方法&quot;&gt;&lt;/a&gt;runtime常用方法&lt;/h2&gt;&lt;p&gt;1.类结构：&lt;/p&gt;
&lt;figure class=&quot;highligh
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-Notification</title>
    <link href="williamliuwen.cn/2016/07/09/AWblog/2016/7/iOS-Notification/"/>
    <id>williamliuwen.cn/2016/07/09/AWblog/2016/7/iOS-Notification/</id>
    <published>2016-07-08T22:01:34.000Z</published>
    <updated>2016-08-13T13:35:51.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-Thread</title>
    <link href="williamliuwen.cn/2016/07/02/AWblog/2016/7/iOS-Thread/"/>
    <id>williamliuwen.cn/2016/07/02/AWblog/2016/7/iOS-Thread/</id>
    <published>2016-07-02T08:52:50.000Z</published>
    <updated>2016-08-13T13:36:16.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Thread方案&quot;&gt;&lt;a href=&quot;#Thread方案&quot; class=&quot;headerlink&quot; title=&quot;Thread方案&quot;&gt;&lt;/a&gt;Thread方案&lt;/h2&gt;&lt;p&gt;1.NSOperation&lt;/p&gt;
&lt;p&gt;2.GCD&lt;/p&gt;
&lt;p&gt;3.NSThread&lt;/p&gt;
&lt;p&gt;4.Thread须知？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.xxx&lt;/li&gt;
&lt;li&gt;2.xxx&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Thread-NSThread&quot;&gt;&lt;a href=&quot;#Thread-NSThread&quot; class=&quot;headerlink&quot; title=&quot;Thread - NSThread&quot;&gt;&lt;/a&gt;Thread - NSThread&lt;/h2&gt;&lt;p&gt;1.NSThread须知？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）NSThread使用的优点和局限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.NSThread使用注意？&lt;/p&gt;
&lt;p&gt;3.NSThread常用属性和方法？&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Thread-GCD&quot;&gt;&lt;a href=&quot;#Thread-GCD&quot; class=&quot;headerlink&quot; title=&quot;Thread - GCD&quot;&gt;&lt;/a&gt;Thread - GCD&lt;/h2&gt;&lt;h3 id=&quot;1-GCD须知？&quot;&gt;&lt;a href=&quot;#1-GCD须知？&quot; class=&quot;headerlink&quot; title=&quot;1.GCD须知？&quot;&gt;&lt;/a&gt;1.GCD须知？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1）GCD使用的优点和局限&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.GCD是苹果公司为多核的并行运算提出的解决方案&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.GCD会自动利用更多的CPU内核（比如双核、四核）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.GCD的高级功能：监视进程或者监视文件夹内文件的变化之类的比较合适。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2）GCD 全称是Grand Central Dispatch，可译为“牛逼的中枢调度器”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;GCD-串行、并行、异步、同步&quot;&gt;&lt;a href=&quot;#GCD-串行、并行、异步、同步&quot; class=&quot;headerlink&quot; title=&quot;GCD - 串行、并行、异步、同步&quot;&gt;&lt;/a&gt;GCD - 串行、并行、异步、同步&lt;/h5&gt;&lt;p&gt;1.什么是串行？&lt;/p&gt;
&lt;p&gt;串行就是一个接一个执行，串行是任务A执行完了任务B才能执行, 它们俩只能顺序执行&lt;/p&gt;
&lt;p&gt;2.什么是并行？&lt;/p&gt;
&lt;p&gt;并行就是多个可以一起执行，并行则是任务A和任务B可以同时执行&lt;/p&gt;
&lt;p&gt;3.什么是同步（ dispatch_sync ）？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1)同步就是，比如用来下载图片的函数A，同步函数只有在image下载结束之后才返回，下载的这段时间函数A只能搬个小板凳在那儿坐等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2)只能在当前线程中执行任务，不具备开启新线程的能力&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.什么是异步（ dispatch_async）？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1)异步，异步函数, 立即返回,图片会去下载 但函数A不会去等它完成，因此异步函数不会堵塞当前线程去执行下一个函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2)可以在新的线程中执行任务，具备开启新线程的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3)异步（dispatch_async）是多线程的代名词&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.串行、并行、异步、同步与线程的关系？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步（ dispatch_sync）不会开启新线程，暂停执行所有不以block块任务为第一任务的队列，阻塞&lt;/li&gt;
&lt;li&gt;异步（ dispatch_async）不一定会开启新线程，这个跟队列有关，当前线程会直接往下执行，它不会阻塞当前线程&lt;/li&gt;
&lt;li&gt;同步执行和异步执行，他们之间的区别主要在于会不会阻塞当前线程,同步会让系统判定暂停执行所有不以block块任务为第一任务的队列（即如果block块任务不在队列头，那么block块任务所在的队列也会暂停执行），且同步一定不会开启新线程，因为GCD觉得既然其它队列暂停执行，block块任务就可以在当前线程执行了，没有必要开启新线程。而异步则系统不会进行判定，但是不一定会开启新线程，这个跟队列有关，如果是新创建的队列，那么GCD就会开启新线程，如果加入已有的队列，那么就会在队列所在的线程中执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;GCD-队列、主队列、全局队列、自定义队列、任务、串行队列、并发队列&quot;&gt;&lt;a href=&quot;#GCD-队列、主队列、全局队列、自定义队列、任务、串行队列、并发队列&quot; class=&quot;headerlink&quot; title=&quot;GCD - 队列、主队列、全局队列、自定义队列、任务、串行队列、并发队列&quot;&gt;&lt;/a&gt;GCD - 队列、主队列、全局队列、自定义队列、任务、串行队列、并发队列&lt;/h5&gt;&lt;p&gt;1.队列与任务关系?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）队列是用来放置任务的，一个队列可以有很多任务，同时也会有很多队列。&lt;/li&gt;
&lt;li&gt;2）所以操作任务的一般步骤是：第一步先确定想做的事情，就是定制任务；第二步是将任务添加到队列中，GCD会自动将队列中的任务取出，放到对应的线程中执行；注意：任务的取出遵循队列的FIFO原则：先进先出，后进后出；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.任务是什么？&lt;/p&gt;
&lt;p&gt;任务就是想要做的事，表示执行什么操作&lt;/p&gt;
&lt;p&gt;3.队列是什么？&lt;/p&gt;
&lt;p&gt;用来存放任务&lt;/p&gt;
&lt;p&gt;4.并发队列（Concurrent Dispatch Queue）是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）&lt;/li&gt;
&lt;li&gt;2）并发功能只有在异步（dispatch_async）函数下才有效&lt;/li&gt;
&lt;li&gt;3）全局队列就是并发队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.串行队列（Serial Dispatch Queue）是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）&lt;/li&gt;
&lt;li&gt;2）串行和并行是针对同一个队列中的任务而言的，当使用串行，那么队列里的那么队列里的任务最多只能使用一个线程运行，即同一时刻只有一个任务在执行，如果是并行，那么系统会根据队列里的任务自动分配线程执行，最大线程数根据参数设定。&lt;/li&gt;
&lt;li&gt;3）主队列就是串行队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6.自定义队列（Serial Dispatch Queue）是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）自定义队列可以是串行队列，也可以是并行队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-GCD使用注意？&quot;&gt;&lt;a href=&quot;#2-GCD使用注意？&quot; class=&quot;headerlink&quot; title=&quot;2.GCD使用注意？&quot;&gt;&lt;/a&gt;2.GCD使用注意？&lt;/h3&gt;&lt;h3 id=&quot;3-GCD常用属性和方法？&quot;&gt;&lt;a href=&quot;#3-GCD常用属性和方法？&quot; class=&quot;headerlink&quot; title=&quot;3.GCD常用属性和方法？&quot;&gt;&lt;/a&gt;3.GCD常用属性和方法？&lt;/h3&gt;&lt;p&gt;1.dispatch_sync// 同步执行&lt;/p&gt;
&lt;p&gt;2.dispatch_async// 异步执行&lt;/p&gt;
&lt;p&gt;3.dispatch_once_t// 保证某段代码在程序运行过程中只被执行1次&lt;/p&gt;
&lt;p&gt;4.dispatch_after// 延时&lt;/p&gt;
&lt;p&gt;5.dispatch_group_async// 组异步&lt;/p&gt;
&lt;p&gt;6.dispatch_suspend// 挂起&lt;/p&gt;
&lt;p&gt;7.dispatch_resume// 继续&lt;/p&gt;
&lt;p&gt;8.dispatch_barrier_async//  作用是在并行队列中，等待前面的队列执行完成后在继续往下执行&lt;/p&gt;
&lt;p&gt;9.dispatch_queue_t// 队列&lt;/p&gt;
&lt;p&gt;10.dispatch_apply&lt;/p&gt;
&lt;p&gt;11.[NSThread sleepForTimeInterval:1.0]; //线程休眠,等同于sleep(1)&lt;/p&gt;
&lt;p&gt;12.dispatch_queue_t queue = dispatch_get_main_queue(); // 创建主队列&lt;/p&gt;
&lt;h3 id=&quot;4-GCD-Dispatch-Source函数&quot;&gt;&lt;a href=&quot;#4-GCD-Dispatch-Source函数&quot; class=&quot;headerlink&quot; title=&quot;4.GCD - Dispatch Source函数&quot;&gt;&lt;/a&gt;4.GCD - Dispatch Source函数&lt;/h3&gt;&lt;p&gt;1.Dispatch Source函数须知？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）Source 可以理解为产生事件的地方，Source 产生事件，然后 Source 的回调函数负责 处理这些事件。&lt;/li&gt;
&lt;li&gt;2）iOS 中有两种 Source，一种是 Run Loop Source ,一种是 Dispatch Source。&lt;/li&gt;
&lt;li&gt;3）在 Run Loop 中， Run Loop Source 产生事件，之后唤醒 Run Loop， Run Loop 便执行该 Source 的回调函数。&lt;/li&gt;
&lt;li&gt;4）Dispatch Source 也会产生一些特定的事件，当这些事件发生的时候，其回调的 block （响应句柄）会自动加入到 对应的 dispatch queue 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.Dispatch Source 种类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_TIMER             定时器&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_SIGNAL            接收到 UNIX 信号&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_READ              文件可读&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_WRITE             文件可写&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_VNODE             文件系统有变更&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_PROC              与进程相关的事件&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_MACH_SEND Mach    端口发送事件&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_MACH_RECV Mach    端口接收事件&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_DATA_ADD          用户自定义的事件－变量相加&lt;/li&gt;
&lt;li&gt;DISPATCH_SOURCE_TYPE_DATA_OR           用户自定义的事件－变量相或&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.选择Dispatch Source还是dispatch_async？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）Dispatch Source优势是可以利用联结dispatch_source_merge_data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.Dispatch Source常用属性和方法？&lt;/p&gt;
&lt;p&gt;dispatch_source_create//创建&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Thread-NSOperation&quot;&gt;&lt;a href=&quot;#Thread-NSOperation&quot; class=&quot;headerlink&quot; title=&quot;Thread - NSOperation&quot;&gt;&lt;/a&gt;Thread - NSOperation&lt;/h2&gt;&lt;h3 id=&quot;1-NSOperation须知？&quot;&gt;&lt;a href=&quot;#1-NSOperation须知？&quot; class=&quot;headerlink&quot; title=&quot;1.NSOperation须知？&quot;&gt;&lt;/a&gt;1.NSOperation须知？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1）NSOperation使用的优点和局限&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-NSOperation使用注意？&quot;&gt;&lt;a href=&quot;#2-NSOperation使用注意？&quot; class=&quot;headerlink&quot; title=&quot;2.NSOperation使用注意？&quot;&gt;&lt;/a&gt;2.NSOperation使用注意？&lt;/h3&gt;&lt;p&gt;1.为什么在并发情况下需要自己来设定isExecuting和isFinished这两个状态量呢?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1)为什么在并发情况下需要自己来设定isExecuting和isFinished这两个状态量呢?&lt;/li&gt;
&lt;li&gt;2)因为在并发情况下系统不知道operation什么时候finished, operation里面的task一般来说是异步执行的&lt;/li&gt;
&lt;li&gt;3)也就是start函数返回了operation不一定就是finish了, 这个你自己来控制, 你什么时候将isFinished置为YES(发送相应的KVO消息), operation就什么时候完成了&lt;/li&gt;
&lt;li&gt;4)修改的方法：willChangeValueForKey  /  didChangeValueForKey&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;3-NSOperation常用属性和方法？&quot;&gt;&lt;a href=&quot;#3-NSOperation常用属性和方法？&quot; class=&quot;headerlink&quot; title=&quot;3.NSOperation常用属性和方法？&quot;&gt;&lt;/a&gt;3.NSOperation常用属性和方法？&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;-(void)start;//启动任务,默认在当前队列同步执行；当实现了start方法时，默认会执行start方法，而不执行main方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)main;//main函数执行完成后, isExecuting会被置为NO, 而isFinished则被置为YES.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)addDependency:(NSOperation *)op;//依赖可以跨队列依赖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)removeDependency:(NSOperation *)op;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)cancel;//取消任务，GCD没有这个功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)waitUntilFinished ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)addExecutionBlock:(void (^)(void))block;//参考《NSOperation【子类1：NSBlockOperation】》&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(nullable instancetype)initWithTarget:(id)target selector:(SEL)sel object:(nullable id)arg;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(instancetype)initWithInvocation:(NSInvocation *)inv NS_DESIGNATED_INITIALIZER;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)addOperation:(NSOperation *)op;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)addOperations:(NSArray&lt;nsoperation *=&quot;&quot;&gt; *)ops waitUntilFinished:(BOOL)wait ;&lt;/nsoperation&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)addOperationWithBlock:(void (^)(void))block ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)cancelAllOperations;//取消队列中所有的任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;-(void)waitUntilAllOperationsAreFinished;//阻塞当前线程直到此队列中的所有任务执行完毕&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;+(nullable NSOperationQueue *)currentQueue ;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;+(NSOperationQueue *)mainQueue ;//获取主队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;+(instancetype)blockOperationWithBlock:(void (^)(void))block;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property NSInteger maxConcurrentOperationCount;//最大并发数;用来设置最多可以让多少个任务同时执行;为 1 时为串行；主对列默认是串行队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property (readonly) NSUInteger operationCount;//获取队列的任务数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property (readonly, getter=isCancelled) BOOL cancelled;//取消；用KVO可以方便的监测NSOperation的状态(isExecuted, isFinished, isCancelled)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property (readonly, getter=isExecuting) BOOL executing;//正在执行；因为都起了别名，所以可以通过 isExecuting 来 getter 属性值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property (readonly, getter=isFinished) BOOL finished;//完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@property (getter=isSuspended) BOOL suspended;//暂停;[queue setSuspended:YES];是重写 set 方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;NSOperationQueuePriority&quot;&gt;&lt;a href=&quot;#NSOperationQueuePriority&quot; class=&quot;headerlink&quot; title=&quot;NSOperationQueuePriority&quot;&gt;&lt;/a&gt;NSOperationQueuePriority&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;NSOperationQueuePriorityVeryLow = -8L,&lt;/li&gt;
&lt;li&gt;NSOperationQueuePriorityLow = -4L,&lt;/li&gt;
&lt;li&gt;NSOperationQueuePriorityNormal = 0,&lt;/li&gt;
&lt;li&gt;NSOperationQueuePriorityHigh = 4,&lt;/li&gt;
&lt;li&gt;NSOperationQueuePriorityVeryHigh = 8&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;参考连接&quot;&gt;&lt;a href=&quot;#参考连接&quot; class=&quot;headerlink&quot; title=&quot;参考连接&quot;&gt;&lt;/a&gt;参考连接&lt;/h4&gt;&lt;p&gt;1.&lt;a href=&quot;http://www.jianshu.com/p/c56b614db49d&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/c56b614db49d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://alex1212112.github.io/blog/2015/11/24/dispatch-source/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://alex1212112.github.io/blog/2015/11/24/dispatch-source/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Thread方案&quot;&gt;&lt;a href=&quot;#Thread方案&quot; class=&quot;headerlink&quot; title=&quot;Thread方案&quot;&gt;&lt;/a&gt;Thread方案&lt;/h2&gt;&lt;p&gt;1.NSOperation&lt;/p&gt;
&lt;p&gt;2.GCD&lt;/p&gt;
&lt;p&gt;3.NSThread&lt;/p&gt;
&lt;p&gt;4.Thread须知？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.xxx&lt;/li&gt;
&lt;li&gt;2.xxx&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Thread-NSThread&quot;&gt;&lt;a href=&quot;#Thread-NSThread&quot; class=&quot;headerlink&quot; title=&quot;Thread - NSThread&quot;&gt;&lt;/a&gt;Thread - NSThread&lt;/h2&gt;&lt;p&gt;1.NSThread须知？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）NSThread使用的优点和局限&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.NSThread使用注意？&lt;/p&gt;
&lt;p&gt;3.NSThread常用属性和方法？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-Block</title>
    <link href="williamliuwen.cn/2016/06/09/AWblog/2016/6/iOS-Block/"/>
    <id>williamliuwen.cn/2016/06/09/AWblog/2016/6/iOS-Block/</id>
    <published>2016-06-08T22:02:38.000Z</published>
    <updated>2016-08-13T13:34:41.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Block有什么用？&quot;&gt;&lt;a href=&quot;#Block有什么用？&quot; class=&quot;headerlink&quot; title=&quot;Block有什么用？&quot;&gt;&lt;/a&gt;Block有什么用？&lt;/h2&gt;&lt;p&gt;1.代替类&lt;/p&gt;
&lt;p&gt;2.什么时候代替类，当类只有一个函数的时候&lt;/p&gt;
&lt;h2 id=&quot;Block的本质？&quot;&gt;&lt;a href=&quot;#Block的本质？&quot; class=&quot;headerlink&quot; title=&quot;Block的本质？&quot;&gt;&lt;/a&gt;Block的本质？&lt;/h2&gt;&lt;p&gt;1.类和闭包的本质是一样的&lt;/p&gt;
&lt;p&gt;2.类和闭包哪个好用：答案是类&lt;/p&gt;
&lt;p&gt;3.Block的另一个名字闭包&lt;/p&gt;
&lt;p&gt;4.block、代码块、闭包，都是只一样的玩意，是一个GCC 非常模糊的特性，以及 Clang 也有的特性是&lt;/p&gt;
&lt;p&gt;5.Block是带有自动变量的匿名函数；匿名函数顾名思义就是不带名字的函数，在C语言中不允许这样的方法存在，而在OC中的Block则可以用指针来直接调用一个函数，但虽说如此我们还是需要知道指针的名称。&lt;/p&gt;
&lt;p&gt;6.自动变量在Block中的具体表现就是截获自动变量&lt;/p&gt;
&lt;h2 id=&quot;一个标准的Block&quot;&gt;&lt;a href=&quot;#一个标准的Block&quot; class=&quot;headerlink&quot; title=&quot;一个标准的Block&quot;&gt;&lt;/a&gt;一个标准的Block&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;^ NSString *(NSString *a,NSString *b)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* “^”这个符号表示这是一个Block；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 返回值类型：NSString *表示返回值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 参数列表：(NSString a,NSString b)这个括号中是Block的参数，语法和C语言类似&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 变量名在哪里？&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Block调用&quot;&gt;&lt;a href=&quot;#Block调用&quot; class=&quot;headerlink&quot; title=&quot;Block调用&quot;&gt;&lt;/a&gt;Block调用&lt;/h2&gt;&lt;p&gt;1.Block调用1&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int b = 0;// 初始化b变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^blockName)() = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;Input:b=%d&amp;quot;,b);//打印b变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = 3;// 对b变量进行修改，无法修改，原因如下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;blockName();// 调用blockName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;原因：虽然我们在调用blockName之前改变了b的值，但是输出的还是blockName编译时候b的值，所以截获瞬间自动变量就是：在blockName中会保存变量的值，而不会随变量的值的改变而改变。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.Block调用2&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int b = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^blockName)() = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这段代码编译出错，编译器提示的大概就是不能在Block中改变变量的值。因为在Block中截获了变量的瞬间值以后就不能再改变变量的值，如果想要在Block中改变变量的值，那么我们只需要在变量声明的时候加上__Block修饰符，像这样：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__block int b = 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^blockName)() = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b = 3;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Block使用技巧&quot;&gt;&lt;a href=&quot;#Block使用技巧&quot; class=&quot;headerlink&quot; title=&quot;Block使用技巧&quot;&gt;&lt;/a&gt;Block使用技巧&lt;/h2&gt;&lt;p&gt;1.修改闭包内部变量注意，如果该变量在Block外部，需要在变量前面加上__block关键字&lt;/p&gt;
&lt;p&gt;2.在Block中常常会用到weakSelf和strong来处理block的产生循环引用的问题&lt;/p&gt;
&lt;p&gt;3.代码块如果在闭合的圆括号内的话，会返回最后语句的值;例子中返回的是url&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSURL *url = (&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *urlString = [NSString stringWithFormat:@&amp;quot;%@/%@&amp;quot;, baseURLString, endpoint];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[NSURL URLWithString:urlString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4.在Block中不可以对C语言数组进行操作，原因是：不支持&lt;/p&gt;
&lt;p&gt;5.Block可以定义在方法内部，也可以定义在方法外部；&lt;/p&gt;
&lt;p&gt;6.只有调用Block时候，才会执行其内部方法&lt;/p&gt;
&lt;h2 id=&quot;weakSelf和strongSelf&quot;&gt;&lt;a href=&quot;#weakSelf和strongSelf&quot; class=&quot;headerlink&quot; title=&quot;weakSelf和strongSelf&quot;&gt;&lt;/a&gt;weakSelf和strongSelf&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接在 block 里面使用关键词 self&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 block 外定义一个 &lt;strong&gt;weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 &lt;/strong&gt;strong 的引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意：当 block并没有被self对象所引用 时，一般可以直接使用self&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;weakSelf和strongSelf的选择是：如果block不是属性则使用self；是属性但block中调用单个self的方法时用weakSelf；多个方法用strongSelf&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;使用weakSelf&quot;&gt;&lt;a href=&quot;#使用weakSelf&quot; class=&quot;headerlink&quot; title=&quot;使用weakSelf&quot;&gt;&lt;/a&gt;使用weakSelf&lt;/h2&gt;&lt;p&gt;1.持有Block；completionHandler是一个Block；被self调用，那正常来说，block里面不能用self调用方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyViewController *myController = [[MyViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self presentViewController:myController animated:YES completion:self.completionHandler];// 这里是self对block持有&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.当block对象被self持有时，一定要使用weakself避免循环引用,下面的weakSelf如果换成了self就会循环引用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__weak typeof(self) weakSelf = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.completionHandler = ^&amp;#123; // self.completionHandler表示self调用了block，block里面又使用self，用weakSelf替换&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, weakSelf);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.来一个没有使用weakSelf导致运行循环的例子&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self executeBlock:^(NSData *data, NSError *error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self doSomethingWithData:data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;使用strongSelf&quot;&gt;&lt;a href=&quot;#使用strongSelf&quot; class=&quot;headerlink&quot; title=&quot;使用strongSelf&quot;&gt;&lt;/a&gt;使用strongSelf&lt;/h2&gt;&lt;p&gt;1.参考《解决Block循环引用》&lt;/p&gt;
&lt;p&gt;2.什么时候使用weakSelf和strongSelf：参考《weakSelf和strongSelf》&lt;/p&gt;
&lt;p&gt;3.多个方法用strongSelf&lt;/p&gt;
&lt;h2 id=&quot;解决Block循环引用&quot;&gt;&lt;a href=&quot;#解决Block循环引用&quot; class=&quot;headerlink&quot; title=&quot;解决Block循环引用&quot;&gt;&lt;/a&gt;解决Block循环引用&lt;/h2&gt;&lt;p&gt;1.什么时候会出现循环引用？简单来说就是双边引用, 如果block是self类的property (此时self已经retain了block), 然后在block内又引用了self, 这个情况下就肯定会循环引用了&lt;/p&gt;
&lt;p&gt;2.在block体内define一个strong的self, 然后执行的时候判断下self是否还在, 如果在就继续执行下面的操作, 否则return或抛出异常.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__weak typeof(self) weakSelf = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myObj.myBlock =  ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__strong typeof(self) strongSelf = weakSelf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (strongSelf) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[strongSelf doSomething]; // strongSelf != nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// preemption, strongSelf still not nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[strongSelf doSomethingElse]; // strongSelf != nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Probably nothing...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.来一个使用strongSelf错误的例子,因为block里面调用了多个方法，所以建议用strongSelf&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;__weak __typeof(self)weakSelf = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self executeBlock:^(NSData *data, NSError *error) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[weakSelf doSomethingWithData:data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[weakSelf doSomethingWithData:data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h2&gt;&lt;p&gt;1.weakSelf和strongSelf的选择是：如果block不是属性则使用self；是属性但block中调用单个self的方法时用weakSelf；多个方法用strongSelf&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Block有什么用？&quot;&gt;&lt;a href=&quot;#Block有什么用？&quot; class=&quot;headerlink&quot; title=&quot;Block有什么用？&quot;&gt;&lt;/a&gt;Block有什么用？&lt;/h2&gt;&lt;p&gt;1.代替类&lt;/p&gt;
&lt;p&gt;2.什么时候代替类，当类只有一个函数的时候&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SVN-Git</title>
    <link href="williamliuwen.cn/2016/06/08/AWblog/2016/6/SVN-Git/"/>
    <id>williamliuwen.cn/2016/06/08/AWblog/2016/6/SVN-Git/</id>
    <published>2016-06-07T22:24:02.000Z</published>
    <updated>2016-08-13T13:35:27.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;显示和隐藏文件&quot;&gt;&lt;a href=&quot;#显示和隐藏文件&quot; class=&quot;headerlink&quot; title=&quot;显示和隐藏文件&quot;&gt;&lt;/a&gt;显示和隐藏文件&lt;/h2&gt;&lt;p&gt;1.显示系统隐藏文件命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles -bool true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;为什么要使用Git&quot;&gt;&lt;a href=&quot;#为什么要使用Git&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用Git&quot;&gt;&lt;/a&gt;为什么要使用Git&lt;/h2&gt;&lt;p&gt;1.Git的常用命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git version : 查看电脑GIT的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.Git工具安装&lt;/p&gt;
&lt;p&gt;1）如果你下载了Xcode，直接检查Git的版本&lt;/p&gt;
&lt;p&gt;2）如果你没有Xcode，直接单独下载Git&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;为什么要使用SVN&quot;&gt;&lt;a href=&quot;#为什么要使用SVN&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用SVN&quot;&gt;&lt;/a&gt;为什么要使用SVN&lt;/h2&gt;&lt;p&gt;1.没有使用SVN前&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法后悔：做错了一个操作后，没有后悔药可以吃&lt;/li&gt;
&lt;li&gt;版本备份：费空间、费时间&lt;/li&gt;
&lt;li&gt;版本混乱：因版本备份过多造成混乱，难于找回正确的想要的版本&lt;/li&gt;
&lt;li&gt;代码冲突：多人操作同一个文件（团队开发中的常见问题）&lt;/li&gt;
&lt;li&gt;权限控制：无法对源代码进行精确的权限控制&lt;/li&gt;
&lt;li&gt;追究责任：出现了严重的BUG，无法得知是谁干的，容易耍赖&lt;br&gt;*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.使用SVN后&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能追踪一个项目从诞生一直到定案的过程&lt;/li&gt;
&lt;li&gt;记录一个项目的所有内容变化&lt;/li&gt;
&lt;li&gt;方便地查阅特定版本的修订情况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.SVN工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CVS：开启版本控制之门，1990年诞生，“远古时代”的主流源代码管理工具&lt;/li&gt;
&lt;li&gt;SVN：集中式版本控制。是CVS的接班人，速度比CVS快，功能比CVS多且强大。在国内使用率非常高（70%~90%）。&lt;/li&gt;
&lt;li&gt;GIT：分布式版本控制。目前被越来越多的开源项目使用，不过在国内企业尚未大范围普及。gitHub上的代码就是用git管理的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.使用SVN基本操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载服务器代码&lt;/li&gt;
&lt;li&gt;修改本地代码&lt;/li&gt;
&lt;li&gt;提交本地代码&lt;br&gt;&lt;em&gt;
&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.SVN常用命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;svn checkout：将服务器代码完整的下载到本地&lt;/li&gt;
&lt;li&gt;svn commit：将本地修改的内容提交到服务器&lt;/li&gt;
&lt;li&gt;svn update：将服务器最新代码下载到本地&lt;/li&gt;
&lt;li&gt;svn delete：从本地的版本控制库中删除文件&lt;/li&gt;
&lt;li&gt;svn remove：从本地的版本控制库中删除文件&lt;/li&gt;
&lt;li&gt;注意：Checkout只需要做一次&lt;/li&gt;
&lt;li&gt;提醒：每天下班前：commit“可运行版本”  每天上班前：update前一天所有代码&lt;/li&gt;
&lt;li&gt;svn revert 可以用在：不小心写错了很多东西，想撤销所写的东西（还未把修改提交到服务器）&lt;/li&gt;
&lt;li&gt;svn revert 可以用在2：不小心删错了文件，想把文件恢复回来（还未把删除提交到服务器）&lt;/li&gt;
&lt;li&gt;svn update -r 版本号 可以用在：不小心写错了很多东西，想撤销所写的东西（已经把修改提交到服务器）&lt;/li&gt;
&lt;li&gt;svn update -r 版本号 可以用在2：不小心删错了文件，想把文件恢复回来（已经把删除提交到服务器）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6.搭建SVN服务器&lt;/p&gt;
&lt;p&gt;1）服务器用途&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于存储客户端上传的源代码&lt;/li&gt;
&lt;li&gt;可以在Windows上安装Visual SVN Server&lt;/li&gt;
&lt;li&gt;大部分情况下，公司的开发人员不必亲自搭建SVN服务器&lt;br&gt;*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7.搭建SVN客户端&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上传本地的源代码到服务器，或者更新服务器的代码到本地，保持同步&lt;/li&gt;
&lt;li&gt;可以在Mac上使用命令行、Versions、Cornerstone、Xcode&lt;/li&gt;
&lt;li&gt;开发人员就属于客户端这个角色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;8.commit代码的时候选择要忽略的文件&lt;/p&gt;
&lt;p&gt;1）以下三个需要忽略的信息，都在xcuserdata 文件夹下，所以只需要忽略xcuserdata文件夹。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Xcode默认会记住我们当前正在编辑的文件，也就是上次退出项目时停留的文件，下次打开项目会停留在该文件。我们不需要把这些信息共享给同事，所以需要忽略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Xcode会记录目录的打开情况。同事不需要共享。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;断点信息。同事不需要共享。&lt;br&gt;&lt;em&gt;
&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;9.commit代码产生冲突的解决办法&lt;/p&gt;
&lt;p&gt;1）两个人前后都改了同一个位置的代码，先改代码的人先commit。后改代码的没有update就commit，此时就会产生冲突。例如：&lt;/p&gt;
&lt;p&gt;2）经理-&amp;gt;update-&amp;gt;修改了第99行代码-&amp;gt;commit；张三-&amp;gt;修改了第99行代码-&amp;gt;commit。此时就会冲突。&lt;/p&gt;
&lt;p&gt;10.SVN添加静态库报错&lt;/p&gt;
&lt;p&gt;1）注意：静态库拖拽到项目中后，.a文件默认是I（ignore）的，但是.a文件是需要参与编译的，所以需要用命令行把.a文件添加到项目中，然后commit。&lt;/p&gt;
&lt;p&gt;11.SVN添加storyBoard报错&lt;/p&gt;
&lt;p&gt;1）建议：尽量使用xib，这样可以避免多个人同时操作storyBoard。&lt;/p&gt;
&lt;p&gt;2）在原来的Xcode版本中，svn对storyBoard的支持非常不好，鼠标点击一下xib或者storyBoard，xib或者storyBoard就会变成M。现在6.0版本之后，可以点击，但是不可以移动，如果移动xib或者storyBoard也会变为M。因为storyBoard本质是XML。&lt;/p&gt;
&lt;p&gt;3）多个人同时修改storyBoard的后果，storyBoard冲突，导致storyBoard打不开。&lt;/p&gt;
&lt;p&gt;4）和代码冲突类似，如果先往storyBoard的同一个位置添加了一个控件，并且后者在不知道前者在同一个位置添加了控件的情况下也再该位置添加了一个控件，那么两个控件在storyBoard上的位置冲突，后者commit会报错。&lt;/p&gt;
&lt;p&gt;11.使用SVN建议&lt;/p&gt;
&lt;p&gt;1）尽可能修改文件之前先update文件，写一些代码后就立即提交到服务器&lt;/p&gt;
&lt;p&gt;2）尽可能在下班之前半小时就提交代码，这样可以预留出来半小时解决可能存在的冲突&lt;/p&gt;
&lt;p&gt;3）修改公共文件之前尽可能和同事说一声，修改完成后让同事及时更新，不要做哑巴式程序员，多沟通才能避免一些不必要的冲突和误会，不仅是体现出来对工作的认真，也是对同事的尊重&lt;/p&gt;
&lt;p&gt;12.SVN权限&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;read only&lt;/li&gt;
&lt;li&gt;read/write&lt;br&gt;&lt;em&gt;
&lt;/em&gt;&lt;br&gt;*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;13.SVN中文件状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘ ‘ 没有修改&lt;/li&gt;
&lt;li&gt;A 被添加到本地代码仓库&lt;/li&gt;
&lt;li&gt;C 冲突&lt;/li&gt;
&lt;li&gt;D 被删除&lt;/li&gt;
&lt;li&gt;I 被忽略&lt;/li&gt;
&lt;li&gt;M 被修改&lt;/li&gt;
&lt;li&gt;R 被替换&lt;/li&gt;
&lt;li&gt;X 外部定义创建的版本目录&lt;/li&gt;
&lt;li&gt;? 文件没有被添加到本地版本库内&lt;/li&gt;
&lt;li&gt;!文件丢失或者不完整（不是通过svn命令删除的文件）&lt;/li&gt;
&lt;li&gt;~ 受控文件被其他文件阻隔&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;14.Git和SVN区别？&lt;/p&gt;
&lt;p&gt;1）Git是分布式的，SVN不是；&lt;/p&gt;
&lt;p&gt;2）Git复杂，Git adds Complexity,刚开始使用会有些疑惑，因为需要建两个Repositories(Local Repositories &amp;amp; Remote Repositories),指令很多，除此之外你需要知道哪些指令在Local Repository，哪些指令在Remote Repository。&lt;/p&gt;
&lt;p&gt;3）Git下载下来后，在本地不必联网就可以看到所有的log，很方便学习，SVN却需要联网；&lt;/p&gt;
&lt;p&gt;4）SVN在Commit前，我们都建议是先Update一下，跟本地的代码编译没问题，并确保开发的功能正常后再提交，这样其实挺麻烦的，有好几次同事没有先Updata，就Commit了，发生了一些错误，耽误了大家时间，Git可能这种情况会少些。&lt;/p&gt;
&lt;p&gt;5) Git把内容按元数据方式存储，而SVN是按文件：&lt;/p&gt;
&lt;p&gt;6) Git没有一个全局的版本号，而SVN有&lt;/p&gt;
&lt;p&gt;7) Git的checkout是：而对于Git来说，尽管也有checkout命令，但是由于你需要在本地拥有仓库，所以通常从服务器上checkout代码的第一步是使用git clone来获取一个仓库的拷贝，默认的git clone操作同时还会checkout一份远程仓库上当前active的分支&lt;/p&gt;
&lt;p&gt;##&lt;/p&gt;
&lt;h6 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h6&gt;&lt;p&gt;1.&lt;a href=&quot;http://www.cnblogs.com/wsnb/p/4765597.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/wsnb/p/4765597.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://www.cnblogs.com/wsnb/p/4771379.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/wsnb/p/4771379.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;a href=&quot;http://www.jianshu.com/p/d3ebfa27b3ba&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/d3ebfa27b3ba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.&lt;a href=&quot;http://blog.csdn.net/bruce_6/article/details/38299677&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/bruce_6/article/details/38299677&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;a href=&quot;http://blog.csdn.net/a117653909/article/details/8952183&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/a117653909/article/details/8952183&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.&lt;a href=&quot;http://www.jianshu.com/p/cf37ecd0c3a3&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/cf37ecd0c3a3&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;显示和隐藏文件&quot;&gt;&lt;a href=&quot;#显示和隐藏文件&quot; class=&quot;headerlink&quot; title=&quot;显示和隐藏文件&quot;&gt;&lt;/a&gt;显示和隐藏文件&lt;/h2&gt;&lt;p&gt;1.显示系统隐藏文件命令&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;defaults write com.apple.finder AppleShowAllFiles -bool true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;为什么要使用Git&quot;&gt;&lt;a href=&quot;#为什么要使用Git&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用Git&quot;&gt;&lt;/a&gt;为什么要使用Git&lt;/h2&gt;&lt;p&gt;1.Git的常用命令&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git version : 查看电脑GIT的版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.Git工具安装&lt;/p&gt;
&lt;p&gt;1）如果你下载了Xcode，直接检查Git的版本&lt;/p&gt;
&lt;p&gt;2）如果你没有Xcode，直接单独下载Git&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS分类/协议/扩展/代理/数据源</title>
    <link href="williamliuwen.cn/2016/06/04/AWblog/2016/6/iOS%E5%88%86%E7%B1%BB-%E5%8D%8F%E8%AE%AE-%E6%89%A9%E5%B1%95-%E4%BB%A3%E7%90%86-%E6%95%B0%E6%8D%AE%E6%BA%90/"/>
    <id>williamliuwen.cn/2016/06/04/AWblog/2016/6/iOS分类-协议-扩展-代理-数据源/</id>
    <published>2016-06-04T12:37:24.000Z</published>
    <updated>2016-08-13T13:34:53.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;1.分类原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类可以访问原类中的成员变量，但是在分类不能添加任何变量。若需要添加变量可以考虑创建子类&lt;/li&gt;
&lt;li&gt;分类中的方法名可以与原类的某个方法名相同（即重载），但是原类的同名方法将失效，不能访问&lt;/li&gt;
&lt;li&gt;通过分类添加的方法是可以被子类继承的&lt;/li&gt;
&lt;li&gt;不必实现分类的所有方法。可以在分类中声明所有的方法，但不实现，在需要的时候再去实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;4.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;协议&quot;&gt;&lt;a href=&quot;#协议&quot; class=&quot;headerlink&quot; title=&quot;协议&quot;&gt;&lt;/a&gt;协议&lt;/h2&gt;&lt;p&gt;1.协议的原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现此协议的类必须实现对应的方法&lt;/li&gt;
&lt;li&gt;协议中方法是否必须实现，通过关键字进行@required和@optional进行设置&lt;/li&gt;
&lt;li&gt;如果不设置则默认是@required（注意ObjC是弱语法，即使不实现必选方法编译运行也不会报错）&lt;/li&gt;
&lt;li&gt;一个类可以同时实现多个协议，中间通过逗号分隔&lt;/li&gt;
&lt;li&gt;协议的实现只能在类的声明上,不能放到类的实现上（也就是说必须写成@interface Person:NSObject&lt;animaldelegate&gt;而不能写成@implementation Person&lt;animaldelegate&gt;）&lt;/animaldelegate&gt;&lt;/animaldelegate&gt;&lt;/li&gt;
&lt;li&gt;协议中不能定义属性、成员变量等,只能定义方法&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.例如定义一个动物协议，其中有吃的方法；人对象实现这个动物这个协议，不要遵守动物的方法；&lt;/p&gt;
&lt;p&gt;3.代理模式的出现&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事实上在ObjC中协议的更多作用是用于约束一个类必须实现某些方法，而从面向对象的角度而言这个类跟接口并不一定存在某种自然关系，可能是两个完全不同意义上的事物,这种模式我们称之为代理模式（Delegation）。在Cocoa框架中大量采用这种模式实现数据和UI的分离，而且基本上所有的协议都是以Delegate结尾。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.协议和代理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协议和代理是模块化开发和封装的产物&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.模块间通信（举例）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大厨类只做菜 但是菜做好了怎么办，必须及时的上菜，让顾客享用。但是大厨自己不能上菜，所以大厨必须抛出菜做好了的信号，具体这个菜上不上，怎么上，就不是大厨关心的了&lt;/li&gt;
&lt;li&gt;这里的喊一声就实现了通信（抽象点就是用协议）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;// 第一步：大厨把菜做好了，通知自己的代理把菜拿走&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DaChu.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@protocol DaChuDelegate &amp;lt;NSObject&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)doSomethingAftercaiZuohaole;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface DaChu : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*  delegate 是dachu类的一个属性，weak 关键字是为了避免循环引用，&amp;lt;DaChuDelegate&amp;gt;表示遵守DaChuDelegate协议&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*  更加直白点：在大厨心里有一个人接受他的菜好了的信号去做一些事情，具体这个人是谁，大厨不关心，这个人的代号是delegate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, weak) id &amp;lt;DaChuDelegate&amp;gt; delegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)kaiShiZuoCai;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Dachu.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;DaChu.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation DaChu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)kaiShiZuoCai&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;开始做菜&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sleep(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;做好菜了，该上菜了&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//下面这句是判断 一下delegate是否实现了doSomethingAftercaiZuohaole方法，如果delegate没有实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//直接[self.delegate doSomethingAftercaiZuohaole];会crash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ([self.delegate respondsToSelector:@selector(doSomethingAftercaiZuohaole)]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.delegate doSomethingAftercaiZuohaole];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;// 第二步：代理小二遵守大厨的拿菜方法，等大厨通知，把菜拿走&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;XiaoEr.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;DaChu.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface XiaoEr ()&amp;lt;DaChuDelegate&amp;gt;//&amp;lt;DaChuDelegate&amp;gt;表示遵守DaChuDelegate协议，并且实现协议里面的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation XiaoEr&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)XiaoErZhunBei&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;DaChu *dachu1 = [[DaChu alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dachu1.delegate = self;//说明小二充当代理的角色，负责接收菜好了的信号。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[dachu1 kaiShiZuoCai];//大厨开始做菜&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)doSomethingAftercaiZuohaole&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;小二知道了&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;6.分类也可以遵守协议&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface Person(chinaPerson) &amp;lt;NSCopying,NSCoding&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明Person类拥有一个分类chinaPerson，这个分类遵守NSCopying 和NSCoding协议&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;7.定义协议的类和遵守协议的类之间不存在自然关系&lt;/p&gt;
&lt;p&gt;8.协议真正的作用是约束一个类必须实现某些方法；&lt;br&gt;就是说定义协议的类A是用来约束另一个遵守协议的类B必须实现某些方法；&lt;br&gt;并且类A和类B通常不存在关系；可能类A和类B是两个完全不同意义上的东西；&lt;br&gt;而我们把类A和类B这种关系模式称为“代理关系模式”；而“代理关系模式”大量&lt;br&gt;应用在Cocoa框架中，主要解决数据和UI的分离；&lt;/p&gt;
&lt;p&gt;9.按钮点击–&amp;gt;事件机制（非OC语言）&lt;/p&gt;
&lt;p&gt;满足事件机制条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用者订阅了点击事件&lt;/li&gt;
&lt;li&gt;点击的时候会触发这个事件&lt;/li&gt;
&lt;li&gt;OC中没有事件定义，用“代理关系模式”代替&lt;/li&gt;
&lt;li&gt;首先在按钮中，定义按钮的代理，同时使用协议约束这个代理&lt;/li&gt;
&lt;li&gt;（事件的触发者 = 点击按钮的）必须实现协议中的某些方法；&lt;/li&gt;
&lt;li&gt;实现方法的过程中，按钮的处理流程是：&lt;/li&gt;
&lt;li&gt;先检查代理是否实现了按钮定义的协议方法，如果实现了，则调用&lt;/li&gt;
&lt;li&gt;MyListener作为事件触发者，它实现了KCButtonDelegate代理&lt;/li&gt;
&lt;li&gt;事件触发者 = 代理&lt;/li&gt;
&lt;li&gt;使用respondsToSelector方法可以判断一个对象是否实现了某个方法（需要注意方法名不是”onClick”而是“onClick:”，冒号也是方法名的一部分）；&lt;/li&gt;
&lt;li&gt;看下面例子&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;10.例子代码解析&lt;/p&gt;
&lt;p&gt;1）@property (nonatomic,retain) id&lt;kcbuttondelegate&gt; delegate;&lt;br&gt;//id可以表示任何一个ObjC对象类型，类型后面的”&amp;lt;协议名&amp;gt;“用于约束作为&lt;br&gt;这个属性的对象必须实现该协议(注意：使用id定义的对象类型不需要加“*”)；&lt;/kcbuttondelegate&gt;&lt;/p&gt;
&lt;p&gt;11.@class或@protocol&lt;/p&gt;
&lt;p&gt;1）在.h文件中如果使用了另一个文件的类或协议我们可以通过@class或者@protocol进行声明，&lt;br&gt;而不必导入这个文件，这样可以提高编译效率（注意有些情况必须使用@class或@protocol，&lt;br&gt;例如上面KCButton.h中上面声明的KCButtonDelegate协议中用到了KCButton类，&lt;br&gt;而此文件下方的KCButton类声明中又使用了KCButtonDelegate，&lt;br&gt;从而形成在一个文件中互相引用关系，此时必须使用@class或者@protocol声明，&lt;br&gt;否则编译阶段会报错），但是在.m文件中则必须导入对应的类声明文件或协议文件&lt;br&gt;（如果不导入虽然语法检查可以通过但是编译链接会报错）；&lt;/p&gt;
&lt;p&gt;12.一个协议类，一个遵守协议类；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个类定义了一个相同的协议，可以把这个协议抽出来&lt;/li&gt;
&lt;li&gt;能不能把全部东西都抽出来不留任何东西，目前要保留@property(atomic) id&lt;xxdelegate&gt; delegate;&lt;/xxdelegate&gt;&lt;/li&gt;
&lt;li&gt;方法可以抽出来&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;KCButton.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@class KCButton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//一个协议可以扩展另一个协议，例如KCButtonDelegate扩展了NSObject协议&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@protocol KCButtonDelegate &amp;lt;NSObject&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@required                              //@required修饰的方法必须实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)onClick:(KCButton *)button;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@optional                             //@optional修饰的方法是可选实现的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)onMouseover:(KCButton *)button;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)onMouseout:(KCButton *)button;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KCButton : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//代理属性，同时约定作为代理的对象必须实现KCButtonDelegate协议&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,retain) id&amp;lt;KCButtonDelegate&amp;gt; delegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//点击方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)click;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;KCButton.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCButton.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation KCButton&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)click&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;Invoke KCButton&amp;apos;s click method.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//判断_delegate实例是否实现了onClick:方法（注意方法名是&amp;quot;onClick:&amp;quot;,后面有个:）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//避免未实现ButtonDelegate的类也作为KCButton的监听&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if([_delegate respondsToSelector:@selector(onClick:)])&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[_delegate onClick:self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyListener.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@class KCButton;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@protocol KCButtonDelegate;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface MyListener : NSObject&amp;lt;KCButtonDelegate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)onClick:(KCButton *)button;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyListener.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;MyListener.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCButton.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation MyListener&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)onClick:(KCButton *)button&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;Invoke MyListener&amp;apos;s onClick method.The button is:%@.&amp;quot;,button);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;main.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCButton.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;MyListener.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main(int argc, const char * argv[]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@autoreleasepool &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;KCButton *button=[[KCButton alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MyListener *listener=[[MyListener alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//button的delegate属性对象是id任意类型；把listener赋值给它，那listener必须遵守delegate属性规定的协议；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;button.delegate=listener;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[button click];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/* 结果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Invoke KCButton&amp;apos;s click method.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Invoke MyListener&amp;apos;s onClick method.The button is:&amp;lt;KCButton: 0x1001034c0&amp;gt;.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return 0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;扩展&quot;&gt;&lt;a href=&quot;#扩展&quot; class=&quot;headerlink&quot; title=&quot;扩展&quot;&gt;&lt;/a&gt;扩展&lt;/h2&gt;&lt;p&gt;1.&lt;/p&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;h6 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h6&gt;&lt;p&gt;1.&lt;a href=&quot;http://blog.csdn.net/jianxin160/article/details/47753189&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/jianxin160/article/details/47753189&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.&lt;a href=&quot;http://www.cnblogs.com/iyou/p/3636848.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/iyou/p/3636848.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;4.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h2&gt;&lt;p&gt;1.分类原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类可以访问原类中的成员变量，但是在分类不能添加任何变量。若需要添加变量可以考虑创建子类&lt;/li&gt;
&lt;li&gt;分类中的方法名可以与原类的某个方法名相同（即重载），但是原类的同名方法将失效，不能访问&lt;/li&gt;
&lt;li&gt;通过分类添加的方法是可以被子类继承的&lt;/li&gt;
&lt;li&gt;不必实现分类的所有方法。可以在分类中声明所有的方法，但不实现，在需要的时候再去实现&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;/p&gt;
&lt;p&gt;3.&lt;/p&gt;
&lt;p&gt;4.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS人机交互</title>
    <link href="williamliuwen.cn/2016/06/04/AWblog/2016/6/iOS%E4%BA%BA%E6%9C%BA%E4%BA%A4%E4%BA%92/"/>
    <id>williamliuwen.cn/2016/06/04/AWblog/2016/6/iOS人机交互/</id>
    <published>2016-06-04T11:36:27.000Z</published>
    <updated>2016-08-13T13:35:12.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;人机交互摘要&quot;&gt;&lt;a href=&quot;#人机交互摘要&quot; class=&quot;headerlink&quot; title=&quot;人机交互摘要&quot;&gt;&lt;/a&gt;人机交互摘要&lt;/h2&gt;&lt;p&gt;1）将重要内容和功能放到更重要的位置，以便用户可以更容易地关注主要任务&lt;br&gt;一些可行的方法是，将主要元素放置在屏幕的上半部分，并靠近屏幕左侧（基于从左至右的阅读习惯）：&lt;/p&gt;
&lt;p&gt;2）给每个交互元素以足够的间距，以便用户对内容和控件进行操作&lt;br&gt;“可点击控件的点击区域不小于 44 x 44 点&lt;/p&gt;
&lt;p&gt;3）如果只有部分功能不可用，那在用户用到这些功能时提供解释界面或者提示&lt;/p&gt;
&lt;p&gt;4）如果所有的功能都不可用，就向用户展示一个界面去描述问题并建议用户如何纠正&lt;br&gt;这能给用户一种反馈，让他们觉得你的 app 并没有出错。这也会赋予用户以控制感，让他们来决定是采取纠正措施并继续使用你的 app，还是切换到另一个 app。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;5）App 重启后要恢复其状态，以便用户可以从中断的地方继续使用，而不要让用户去记住如何返回之前所在的位置&lt;br&gt;你可以前往「State Preservation and Restoration」了解更多关于高效重建和恢复 app 状态的方式。&lt;/p&gt;
&lt;p&gt;6）显示一个和 app 首屏极其相似的启动画面&lt;br&gt;显示一个和 app 首屏极其相似的启动画面。iOS 会在你的 app 启动的瞬间显示这个启动画面，这可以让用户感觉你的 app 非常快，并让你有足够的时间去加载内容。参阅「启动画面」（第 180 页）了解如何创建启动画面。&lt;/p&gt;
&lt;p&gt;7）避免要求用户提供设置信息&lt;/p&gt;
&lt;p&gt;8）尽可能将登陆延后&lt;br&gt;最好在用户没有登录时就可以通过导航来浏览你的 app 并使用部分功能。用户在在可以做点有用的事情前通常已经从那些强制他们登录的 app 中离开了。&lt;/p&gt;
&lt;p&gt;9）尽可能避免在界面中出现不一致的样式&lt;br&gt;通常来说，拥有相似功能的元素看上去也应该很像。用户常常会认为那些他们所看到的不一致背后必定富有深意，然后花时间去理解它们。&lt;/p&gt;
&lt;p&gt;10）确保主要内容在默认尺寸下可以被阅读和理解&lt;br&gt;例如，用户不应需要滚动才读到重要文本，或者放大图片才能看到主要内容。&lt;/p&gt;
&lt;h2 id=&quot;导航栏样式&quot;&gt;&lt;a href=&quot;#导航栏样式&quot; class=&quot;headerlink&quot; title=&quot;导航栏样式&quot;&gt;&lt;/a&gt;导航栏样式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;导航栏样式原则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）层级式：就是APP常用的界面跳转的样式；&lt;/p&gt;
&lt;p&gt;2）扁平式：就是底部标签栏之间的跳转的样式；&lt;/p&gt;
&lt;p&gt;3）内容/体验主导式：就是打游戏的时候，移动地图看不同的关数的样式；&lt;/p&gt;
&lt;h2 id=&quot;使用模态&quot;&gt;&lt;a href=&quot;#使用模态&quot; class=&quot;headerlink&quot; title=&quot;使用模态&quot;&gt;&lt;/a&gt;使用模态&lt;/h2&gt;&lt;p&gt;1）模态使用场景限制：&lt;br&gt;“非常需要吸引用户注意&lt;br&gt;必须完成自包含任务（或明确放弃），以避免让用户的数据处于不明确状态”&lt;/p&gt;
&lt;p&gt;2）“保持模态任务简短精炼。&lt;br&gt;你不会希望用户将模态视图看成是你 app 中的一个小程序。如果子任务过于复杂，用户在进入模态情境时会忽略他们的主要任务。在创建一个涉及层级视图的模态任务时需要尤为谨慎，因为用户会感到迷茫以及忘记如何原路返回。如果模态任务必须在多个视图中包含子任务，确保在层级之间给用户一个唯一、清晰的路径，并避免产生循环。如需了解使用模态视图的准则，请参阅「模态视图」（第 170 页）。&lt;/p&gt;
&lt;p&gt;3）始终提供一个明显而安全地退出模态任务的方式。&lt;br&gt;当用户退出模态视图时，他们通常会知道其任务会被结束。”&lt;/p&gt;
&lt;p&gt;4）“如果任务需要一系列多层级的模态视图，&lt;br&gt;请确保用户在轻点次顶层视图中的「完成」按钮时知道会发生什么。检查任务流程，以决定次级视图中的「完成」按钮是仅仅完成视图中的部分任务，还是完成整个任务。鉴于存在混淆的可能性，请尽可能避免在附属视图中使用「完成」按钮。&lt;/p&gt;
&lt;p&gt;5）使用警告框传达必要——且可操作——的信息。&lt;br&gt;警告框会中断用户的体验过程，并需要一次点击才能结束，因此让用户获知警告框出现的合理性是很重要的。如需了解更多信息，请参阅「警告框」（第 165 页）。&lt;/p&gt;
&lt;p&gt;6）尊重用户关于接收通知信息的设定。&lt;br&gt;在「设置」中，用户会设置希望以怎样的方式接收来自你的 app 的通知信息。请确保遵循这些设定，以免用户关闭来自你 app 的所有通知消息。”&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;人机交互摘要&quot;&gt;&lt;a href=&quot;#人机交互摘要&quot; class=&quot;headerlink&quot; title=&quot;人机交互摘要&quot;&gt;&lt;/a&gt;人机交互摘要&lt;/h2&gt;&lt;p&gt;1）将重要内容和功能放到更重要的位置，以便用户可以更容易地关注主要任务&lt;br&gt;一些可行的方法是，将主要元素放置在屏幕的上半部分，并靠近屏幕左侧（基于从左至右的阅读习惯）：&lt;/p&gt;
&lt;p&gt;2）给每个交互元素以足够的间距，以便用户对内容和控件进行操作&lt;br&gt;“可点击控件的点击区域不小于 44 x 44 点&lt;/p&gt;
&lt;p&gt;3）如果只有部分功能不可用，那在用户用到这些功能时提供解释界面或者提示&lt;/p&gt;
&lt;p&gt;4）如果所有的功能都不可用，就向用户展示一个界面去描述问题并建议用户如何纠正&lt;br&gt;这能给用户一种反馈，让他们觉得你的 app 并没有出错。这也会赋予用户以控制感，让他们来决定是采取纠正措施并继续使用你的 app，还是切换到另一个 app。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS规范</title>
    <link href="williamliuwen.cn/2016/06/03/AWblog/2016/6/iOS%E8%A7%84%E8%8C%83/"/>
    <id>williamliuwen.cn/2016/06/03/AWblog/2016/6/iOS规范/</id>
    <published>2016-06-03T13:22:13.000Z</published>
    <updated>2016-08-13T13:35:00.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h2&gt;&lt;p&gt;1.iOS命名原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性高、可复用、易维护、可扩展&lt;/li&gt;
&lt;li&gt;防止命名冲突(通过加前缀来保证)&lt;/li&gt;
&lt;li&gt;每个模块都要加上自己的前缀, 前缀在编程接口中非常重要, 可以区分软件的功能范畴并防止不同文件或者类之间命名发生冲突, 比如相册模块(PhotoGallery)的代码都以PG作为前缀: PGAlbumViewController, PGDataManager.&lt;/li&gt;
&lt;li&gt;可扩展则是要求写代码时要考虑后面的扩展需求, 这个属于架构层面的东东, 利用对应的设计模式来保证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.iOS常量命令&lt;/p&gt;
&lt;p&gt;1）对于常量的命名最好在前面加上字母k作为标记. 如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static const NSTimeInterval kAnimationDuration = 0.3;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2）定义作为NSDictionary或者Notification等的Key值字符串时加上const关键字, 以防止被修改. 如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *const UIApplicationDidEnterBackgroundNotification&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3）若常量作用域超出编译单元(实现文件), 需要在类外可见时, 使用extern关键字, 并加上该类名作为前缀. 如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern NSString *const PGThumbnailSize&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;3.iOS枚举命令&lt;/p&gt;
&lt;p&gt;枚举类型命名要加相关类名前缀并且枚举值命名要加枚举类型前缀.&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_ENUM(NSInteger, UIViewAnimationTransition) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationTransitionNone,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationTransitionFlipFromLeft,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationTransitionFlipFromRight,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationTransitionCurlUp,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIViewAnimationTransitionCurlDown,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4.iOS变量和对象命名&lt;/p&gt;
&lt;p&gt;1）给一个对象命名时建议采用修饰+类型的方式&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;titleLabel    //表示标题的label,  是UILabel类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;confirmButton //表示确认的button, 是UIButton类型&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2）对于BOOL类型, 应加上is前缀&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)isEqualToString:(NSString *)aString&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3）如果某方法返回非属性的 BOOL 值, 那么应根据其功能, 选用 has 或 is 当前缀, 如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)hasPrefix:(NSString *)aString&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4）如果某个命名已经很明确了, 为了简洁可以省去类型名. 比如scores, 很明显是个array了, 就不必命名成scoreArray了&lt;/p&gt;
&lt;p&gt;5.iOS命名常规错误&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UserFollowerTableViewController    // 不推荐&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UserFollowerListController         // OK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UserLikedTagListController         // 不推荐&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;TagUserLikedListController         // OK，把显示的对象放在第一位&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;6.iOS通知命名&lt;/p&gt;
&lt;p&gt;这里学习iOS的命名方法：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSApplicationDidBecomeActiveNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSWindowDidMiniaturizeNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSTextViewDidChangeSelectionNotification&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSColorPanelColorDidChangeNotification&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;7.类名、局部变量、类成员命名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类名采用大驼峰（UpperCamelCase）&lt;/li&gt;
&lt;li&gt;类成员、方法小驼峰（lowerCamelCase）&lt;/li&gt;
&lt;li&gt;局部变量大小写首选小驼峰，也可使用小写下划线的形式（snake_case）&lt;/li&gt;
&lt;li&gt;C函数的命名用大驼峰&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;8.命名规范–函数命名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1)如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用do，does这种多余的关键字，动词本身的暗示就足够了;动词打头的方法表示让对象执行一个动作&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)invokeWithTarget:(id)target;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)selectTabViewItem:(NSTabViewItem *)tabViewItem;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2)如果方法是为了获取对象的一个属性值，直接用属性名称来命名这个方法，注意不要添加get或者其他的动词前缀&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确，使用属性名来命名方法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)cellSize;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;错误，添加了多余的动词前缀&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)calcCellSize;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSSize)getCellSize;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3)对于有多个参数的方法，务必在每一个参数前都添加关键词，关键词应当清晰说明参数的作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正确，保证每个参数都有关键词修饰&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sendAction:(SEL)aSelector toObject:(id)anObject forAllCells:(BOOL)flag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;错误，遗漏关键词&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;正确&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)viewWithTag:(NSInteger)aTag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;错误，关键词的作用不清晰&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (id)taggedView:(int)aTag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4)不要用and来连接两个参数，通常and用来表示方法执行了两个相对独立的操作（从设计上来说，这时候应该拆分成两个独立的方法）：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;错误，不要使用”and”来连接参数&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (int)runModalForDirectory:(NSString *)path andFile:(NSString *)name andTypes:(NSArray *)fileTypes;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;正确，使用”and”来表示两个相对独立的操作&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)openFile:(NSString *)fullPath withApplication:(NSString *)appName andDeactivate:(BOOL)flag;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;9.命名规范–分组命名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用英文，首字母大写，之后每个单词首字母都大写&lt;/li&gt;
&lt;li&gt;每个分组使用模块的名字&lt;/li&gt;
&lt;li&gt;使用的开源库统一放在“Library”分组下&lt;/li&gt;
&lt;li&gt;使用的公共组件统一放在“Common”分组下&lt;/li&gt;
&lt;li&gt;视图控制器及AppDelegate统一放在“Controllers”分组下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;10.命名规范–图片命名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用英文，首字母大写，之后每个单词首字母都大写&lt;/li&gt;
&lt;li&gt;添加模块名作为前缀，避免冲突&lt;/li&gt;
&lt;li&gt;图片应该与类文件一样，按模块分组放置&lt;/li&gt;
&lt;li&gt;只要文件名叫做Icon.png，就会自动被当做是应用程序的图标&lt;/li&gt;
&lt;li&gt;一个应用程序可以准备多种规格的图标，详情可以查看苹果官方文档，ios7 doc set/user expreience/guides/app icons on iPad and iphone&lt;/li&gt;
&lt;li&gt;一个app在启动过程中会全屏显示叫做Default.png的图片&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;11.命名规范–特殊类命名&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是视图控制器的子类应添加后缀“ViewController”或者“Controller”&lt;/li&gt;
&lt;li&gt;如果是视图的子类应添加后缀“View”&lt;/li&gt;
&lt;li&gt;如果是按钮的子类应添加后缀“Button”&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命名规范–补充命名&lt;/p&gt;
&lt;p&gt;常量（预定义，局部常量等）使用小写k开头的驼峰法&lt;br&gt;举例：kInvalidHandle , kWritePerm&lt;/p&gt;
&lt;p&gt;枚举类型命名首字母大写，之后每个单词首字母都大写，最后加“s”&lt;br&gt;枚举变量使用枚举类型去掉“s”作为前缀，每个单词首字母大写，中间不允许加下划线&lt;br&gt;举例：&lt;br&gt;typedef enum UIControlEvents{&lt;br&gt;UIControlEventTouchDown,&lt;br&gt;UIControlEventTouchUpInside&lt;br&gt;}UIControlEvents;&lt;/p&gt;
&lt;h2 id=&quot;编码规范&quot;&gt;&lt;a href=&quot;#编码规范&quot; class=&quot;headerlink&quot; title=&quot;编码规范&quot;&gt;&lt;/a&gt;编码规范&lt;/h2&gt;&lt;p&gt;1.编码规范–判断nil或者YES/NO&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (someObject) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!someObject) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2.编码规范–条件赋值&lt;/p&gt;
&lt;p&gt;如果是存在就赋值本身, 那就可以这样简写&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;result = object ? : [self createObject];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3.编码规范–初始化方法&lt;/p&gt;
&lt;p&gt;初始化的时候，直接赋值的好处是：&lt;/p&gt;
&lt;p&gt;第一个好处还是简洁&lt;/p&gt;
&lt;p&gt;第二个好处是可以防止初始化进去nil值造成crash&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray *names = @[@&amp;quot;Brian&amp;quot;, @&amp;quot;Matt&amp;quot;, @&amp;quot;Chris&amp;quot;, @&amp;quot;Alex&amp;quot;, @&amp;quot;Steve&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *productManagers = @&amp;#123;@&amp;quot;iPhone&amp;quot; : @&amp;quot;Kate&amp;quot;, @&amp;quot;iPad&amp;quot; : @&amp;quot;Kamal&amp;quot;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSNumber *shouldUseLiterals = @YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSNumber *buildingZIPCode = @10018;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;4.编码规范–定义属性&lt;/p&gt;
&lt;p&gt;1）建议定义属性的时候把所有的参数写全, 尤其是如果想定义成只读的(防止外面修改)那一定要加上readonly, 这也是代码安全性的一个习惯.&lt;/p&gt;
&lt;p&gt;2）如果是内部使用的属性, 那么就定义成私有的属性(定义到.m的class extension里面)&lt;br&gt;对于拥有Mutable子类型的对象(e.g. NSString, NSArray, NSDictionary)一定要定义成copy属性. Why? 示例: NSArray的array = NSMutableArray的mArray; 如果mArray在某个地方改变了, 那array也会跟着改变. So, make sense?&lt;/p&gt;
&lt;p&gt;3）尽量不要暴露mutable类型的对象在public interface, 建议在.h定义一个Inmutable类型的属性, 然后在.m的get函数里面返回一个内部定义的mutable变量. Why? For security as well!&lt;/p&gt;
&lt;p&gt;@property (nonatomic, readwrite, copy) NSString *name;&lt;/p&gt;
&lt;p&gt;5.编码规范–BOOL赋值&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BOOL isAdult = age &amp;gt; 18;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;6.编码规范–拒绝死值&lt;/p&gt;
&lt;p&gt;1）死值每次修改的时候容易被遗忘, 地方多了找起来就悲剧了. 而且定义成枚举或者static可以让错误发生在编译阶段. 另外仅仅看到一个数字, 完全不知道这个数字代表的意义. 纳尼?&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (car == Car.Nissan)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;or&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const int adultAge = 18; if (age &amp;gt; adultAge) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;7.编码规范–复杂的条件判断&lt;/p&gt;
&lt;p&gt;清晰明了, 每个函数只做一件事!&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if ([self canDeleteJob:job]) &amp;#123; ... &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)canDeleteJob:(Job *)job&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL invalidJobState = job.JobState == JobState.New&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|| job.JobState == JobState.Submitted&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;|| job.JobState == JobState.Expired;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL invalidJob = job.JobTitle &amp;amp;&amp;amp; job.JobTitle.length;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return invalidJobState || invalidJob;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;8.编码规范–嵌套判断&lt;/p&gt;
&lt;p&gt;一旦发现某个条件不符合, 立即返回, 条理更清晰&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (!user.UserName) return NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!user.Password) return NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (!user.Email) return NO;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return YES;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;9.编码规范–参数过多&lt;/p&gt;
&lt;p&gt;当发现实现某一功能需要传递的参数太多时, 就预示着你应该聚合成一个model类了…这样代码更整洁, 也不容易因为参数太多导致出错&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;user里面有userName、password、email&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)registerUser(User *user)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// to do...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;10.编码规范–把方法进行分类&lt;/p&gt;
&lt;p&gt;1）使用#pragma mark –来分类方法&lt;/p&gt;
&lt;p&gt;#pragma mark – Life Cycle//代表生命周期方法&lt;/p&gt;
&lt;p&gt;#pragma mark - Events//代表事件&lt;/p&gt;
&lt;p&gt;#pragma mark – Private Methods//代表私有方法&lt;/p&gt;
&lt;p&gt;#pragma mark - UITextFieldDelegate//代理&lt;/p&gt;
&lt;p&gt;#pragma mark - UITableViewDataSource//数据源&lt;/p&gt;
&lt;p&gt;#pragma mark - UITableViewDelegate//代理&lt;/p&gt;
&lt;p&gt;#pragma mark - Custom Delegates//自定义代理&lt;/p&gt;
&lt;p&gt;#pragma mark – Getters and Setters//getter和setter方法&lt;/p&gt;
&lt;p&gt;11.编码规范–注释符号&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                文件引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                 宏定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                 常量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                类型定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                全局变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                 原型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/ ***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                类特性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/ ***************************************************************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*                                类的实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***************************************************************************/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块代码注释符号&lt;br&gt;1）块注释风格1&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/////////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// @name UIButton控件生成相关API&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/////////////////////////////////////&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）块注释风格2&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 块功能说明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3）块注释风格3&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 块功能说明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用#program mark -  注释内容&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;#program mark 是每个ios程序员都必须会用的技巧，通过#program mark 把代码分为个个部分，良好的注释是好代码的开始&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注释原则&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;代码中尽量少注释，让代码能自我描述。不过当需要注释的时候，能需要清除的解释某个代码块的含义和作用。注释应当保持最新，如果不必要请删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;#pragma clang 使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1）取消xcode编译器内对于启用方法的警告&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic ignored &amp;quot;-Wdeprecated-declarations&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// CODE:这段中出现使用所有的弃用方法都不会产生告警&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2）取消对未使用变量的警告，使用方法和上面相同，必须成对出现#pragma clang&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//方法1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;diagnostic ---&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic ignored &amp;quot;-Wunused-variable&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//方法2：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma unused (foo)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3）忽略内存泄露告警&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic push&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic ignored &amp;quot;-Warc-performSelector-leaks&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[someController performSelector: NSSelectorFromString(@&amp;quot;someMethod&amp;quot;)]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma clang diagnostic pop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;手动产生一条警告&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#warning :手动产生一条告警&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手动产生一条错误&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;#error : 手动产生一条错误&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;12.编码规范–花括号空格&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)methodName:(NSString *)string &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;↑空格                              ↑空格，推荐花括号在一行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;空格↑  ↑空格，花括号不要另起一行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;要换行↑ ↑空格，花括号不要另起一行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;13.编码规范–编码注意&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单个文件方法数不应超过30个&lt;/li&gt;
&lt;li&gt;不要按类别排序（如把IBAction放在一块），应按任务把相关的组合在一起&lt;/li&gt;
&lt;li&gt;禁止出现超过两层循环的代码，用函数或block替代&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;14.编码规范–编码例子&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;糟糕&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (Task *)creatTaskWithPath:(NSString *)path &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Task *aTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ([path isURL]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ([fileManager isWritableFileAtPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (![taskManager hasTaskWithPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;aTask = [[Task alloc] initWithPath:path];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return aTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*建议&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (Task *)creatTaskWithPath:(NSString *)path &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (![path isURL]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (![fileManager isWritableFileAtPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if ([taskManager hasTaskWithPath:path]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Task *aTask = [[Task alloc] initWithPath:path];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return aTask;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;15.编码规范–编码注释适当使用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尽量让代码可以自表述，而不是依赖注释。&lt;/li&gt;
&lt;li&gt;注释应该表达那些代码没有表达以及无法表达的东西。&lt;/li&gt;
&lt;li&gt;如果一段注释被用于解释一些本应该由这段代码自己表达的东西，我们就应该将这段注释看成一个改变代码结构或编码惯例直至代码可以自我表达的信号。&lt;/li&gt;
&lt;li&gt;我们重命名那些糟糕的方法和类名，而不是去修补。我们选择将长函数中的一些代码段抽取出来形成一些小函数，这些小函数的名字可以表述原代码段的意图，而不是对这些代码段进行注释。&lt;/li&gt;
&lt;li&gt;尽可能的通过代码进行表达。你通过代码所能表达的和你想要表达的所有事情之间的差额将为注释提供了一个合理的候选使用场合。对那些代码无法表达的东西进行注释，而不要仅简单地注释那些代码没有表达的东西。&lt;/li&gt;
&lt;li&gt;方法内部禁止使用块注释。除非要临时注释大段代码，一般情况总应使用行注释。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;16.编码规范–参数分行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正确使用：如果第一段名称过短，后续名称可以以Tab的长度（4个空格）为单位进行缩进&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)short:(GTMFoo *)theFoo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;longKeyword:(NSRect)theRect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;evenLongerKeyword:(float)theInterval&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error:(NSError **)theError &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误使用：要么写在一行，要么全部分行&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[myObject doFooWith:arg1 name:arg2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;error:arg3];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myObject doFooWith:arg1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name:arg2 error:arg3];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;17.编码规范–冒号两边&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;正确，在语法糖的”[]”或者”{}”两端留有空格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray *array = @[ [foo description], @&amp;quot;Another String&amp;quot;, [bar description] ];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *dict = @&amp;#123; NSForegroundColorAttributeName : [NSColor redColor] &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造字典时，字典的Key和Value与中间的冒号:都要留有一个空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正确，冒号’:’前后留有一个空格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *option1 = @&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSFontAttributeName : [NSFont fontWithName:@&amp;quot;Helvetica-Bold&amp;quot; size:12],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSForegroundColorAttributeName : fontColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;正确，按照Value来对齐&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *option2 = @&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSFontAttributeName :            [NSFont fontWithName:@&amp;quot;Arial&amp;quot; size:12],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSForegroundColorAttributeName : fontColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误，冒号前应该有一个空格&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *wrong = @&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AKey:       @&amp;quot;b&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BLongerKey: @&amp;quot;c&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误，每一个元素要么单独成为一行，要么全部写在一行内&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *alsoWrong= @&amp;#123; AKey : @&amp;quot;a&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BLongerKey : @&amp;quot;b&amp;quot; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;错误，在冒号前只能有一个空格，冒号后才可以考虑按照Value对齐&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSDictionary *stillWrong = @&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;AKey       : @&amp;quot;b&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BLongerKey : @&amp;quot;c&amp;quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;18.编码规范–程序布局&lt;/p&gt;
&lt;p&gt;1）程序布局目的：程序布局的目的是显示出程序良好的逻辑结构，提高程序的准确性、连续性、可读性、可维护性。更重要的是，统一的程序布局和编程风格，有助于提高整个项目的开发质量，提高开发效率，降低开发成本。同时，对于普通程序员来说，养成良好的编程习惯有助于提高自己的编程水平，提高编程效率。因此，统一的、良好的程序布局和编程风格不仅仅是个人主观美学上的或是形式上的问题，而且会涉及到产品质量，涉及到个人编程能力的提高，必须引起大家重视。&lt;/p&gt;
&lt;p&gt;2）布局中的空格：每个方法或者功能块之间为了结构清晰，应当有且只有一行空格,如下示例&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface SomeClass:NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (noatomic, strong) UIView *aView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)someMethod;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation SomeClass&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setAView:(NSInteger )aview &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)someMethod &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3）布局中的Private Methods块：正常情况下ViewController里面不应该写&lt;br&gt;不是delegate方法的，不是event response方法的，不是life cycle方法的，就是private method了。对的，正常情况下ViewController里面一般是不会存在private methods的，这个private methods一般是用于日期换算、图片裁剪啥的这种小功能。这种小功能要么把它写成一个category，要么把他做成一个模块，哪怕这个模块只有一个函数也行。&lt;/p&gt;
&lt;p&gt;ViewController基本上是大部分业务的载体，本身代码已经相当复杂，所以跟业务关联不大的东西能不放在ViewController里面就不要放。另外一点，这个private method的功能这时候只是你用得到，但是将来说不定别的地方也会用到，一开始就独立出来，有利于将来的代码复用。&lt;/p&gt;
&lt;p&gt;4）布局中的初始化方法放哪里？&lt;/p&gt;
&lt;p&gt;属性初始化放哪最好？建议在Getter中初始化&lt;/p&gt;
&lt;p&gt;我看到很多APP，甚至我公司的项目，很多开发工程师，初始化属性的位置比较随意，有单独添加一个初始化方法类似setupView的，有在init初始化的，各种情况都有，我其实挺崩溃的，首先初始化方式不一致，其次这样做非常可能破坏了每个方法功能的单一性（每个方法只做一件事）。我比较习惯一个对象的”私有”属性写在extension里面，然后这些属性的初始化全部放在getter里面做，在init和dealloc之外，是不会出现任何类似_property这样的写法的。就是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface CustomObject()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong) UILabel *label;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - getters and setters&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UILabel *)label &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (_label == nil) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_label = [[UILabel alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_label.text = @&amp;quot;1234&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_label.font = [UIFont systemFontOfSize:12];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;... ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return _label;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - life cycle&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.view addSubview:self.label];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewWillAppear:(BOOL)animated &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[super viewWillAppear:animated];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.label.frame = CGRectMake(1, 2, 3, 4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5）布局中的Getters and Setters放在最底部&lt;/p&gt;
&lt;p&gt;一个view可能会有非常多的view和其他属性,如果getters and setters放在前面，就会导致在implementation代码顶部有大量的初始化代码，这就导致主要的逻辑代码挪到后面去了，其他人阅读代码是不太方便的。&lt;/p&gt;
&lt;p&gt;19.编码规范–表达式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if语句&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;表达式大括号和其他大括号(if/else/switch/while 等.)总是在同一行语句打开但在新行中关闭。如果没有else 并且括号内只有一行语句，可以和if语句同行，并且不需要括号。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if (user.isHappy) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//Do something&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125; else &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//Do something else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if (somethingIsBad) return something;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Switch语句&lt;blockquote&gt;
&lt;p&gt;大括号在case语句中并不是必须的，除非编译器强制要求。当一个case语句包含多行代码时，大括号应该加上。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;switch (condition) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case 2: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Multi-line example using braces&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case 3:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;default:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当在switch使用枚举类型时，’default’是不需要的&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;switch (menuType) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case RWTLeftMenuTopItemMain:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case RWTLeftMenuTopItemShows:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;case RWTLeftMenuTopItemSchedule:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/414bb5a53139&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/414bb5a53139&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命名规范&quot;&gt;&lt;a href=&quot;#命名规范&quot; class=&quot;headerlink&quot; title=&quot;命名规范&quot;&gt;&lt;/a&gt;命名规范&lt;/h2&gt;&lt;p&gt;1.iOS命名原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可读性高、可复用、易维护、可扩展&lt;/li&gt;
&lt;li&gt;防止命名冲突(通过加前缀来保证)&lt;/li&gt;
&lt;li&gt;每个模块都要加上自己的前缀, 前缀在编程接口中非常重要, 可以区分软件的功能范畴并防止不同文件或者类之间命名发生冲突, 比如相册模块(PhotoGallery)的代码都以PG作为前缀: PGAlbumViewController, PGDataManager.&lt;/li&gt;
&lt;li&gt;可扩展则是要求写代码时要考虑后面的扩展需求, 这个属于架构层面的东东, 利用对应的设计模式来保证&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.iOS常量命令&lt;/p&gt;
&lt;p&gt;1）对于常量的命名最好在前面加上字母k作为标记. 如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;static const NSTimeInterval kAnimationDuration = 0.3;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;2）定义作为NSDictionary或者Notification等的Key值字符串时加上const关键字, 以防止被修改. 如:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *const UIApplicationDidEnterBackgroundNotification&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;3）若常量作用域超出编译单元(实现文件), 需要在类外可见时, 使用extern关键字, 并加上该类名作为前缀. 如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;extern NSString *const PGThumbnailSize&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS最佳实践</title>
    <link href="williamliuwen.cn/2016/06/03/AWblog/2016/6/iOS%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>williamliuwen.cn/2016/06/03/AWblog/2016/6/iOS最佳实践/</id>
    <published>2016-06-03T13:19:56.000Z</published>
    <updated>2016-08-13T13:35:19.000Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-AVFoundation</title>
    <link href="williamliuwen.cn/2016/05/12/AWblog/2016/5/iOS-AVFoundation/"/>
    <id>williamliuwen.cn/2016/05/12/AWblog/2016/5/iOS-AVFoundation/</id>
    <published>2016-05-12T12:29:05.000Z</published>
    <updated>2016-08-13T13:33:42.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;音频采样&quot;&gt;&lt;a href=&quot;#音频采样&quot; class=&quot;headerlink&quot; title=&quot;音频采样&quot;&gt;&lt;/a&gt;音频采样&lt;/h2&gt;&lt;p&gt;1）低采样率&lt;/p&gt;
&lt;p&gt;2）高采样率&lt;/p&gt;
&lt;p&gt;3）采样率（采样的次数）越高，波形越接近原波形，不过采样的次数增多，必然会导致存储的数据量要增加，所以我们不可能无限提升采样率。&lt;/p&gt;
&lt;p&gt;4）奈奎斯特频率：当采样率等于波形中最高频率的2倍时，已经足够将波形还原到可接受的程度了；比如：人耳能接受的最高频率为20kHz，所以只要采样率超过40kHz，就可以呈现出可接受的声音。目前常见的CD采样率为44.1kHz。&lt;/p&gt;
&lt;p&gt;5）音频文件的体积，体积=采样率&lt;em&gt;音频位元深度&lt;/em&gt;音道数*时间&lt;/p&gt;
&lt;p&gt;6）音频的位元深度。表示用多少位(bit)定义线性维度上的离散度来保存一个音频样本。位数越高，离散度越多，表示的声音越精确（音质越好）。一般来说16bit比较常见，可以表示65536个离散度。&lt;/p&gt;
&lt;h2 id=&quot;音频压缩&quot;&gt;&lt;a href=&quot;#音频压缩&quot; class=&quot;headerlink&quot; title=&quot;音频压缩&quot;&gt;&lt;/a&gt;音频压缩&lt;/h2&gt;&lt;p&gt;1）脉冲编码调制（Pulse Code Modulation）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对声音进行采样、量化过程被称为脉冲编码调制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）直接脉冲编码调制(Linear Pulse Code Modulation)（ Linear PCM ）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LPCM数据是最原始的音频数据完全无损，但是他的体积非常大，比如一个44.1kHz，16bit，双音道的音频文件，每分钟的数据量为44.1&lt;em&gt;16&lt;/em&gt;2*60kbit=10.3M。一个普通5分钟的音乐就得50M&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3）解决数据量大的问题：压缩算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有损压缩（MP3、AAC、OGG、WMA）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;无损压缩（ALAC、APE、FLAC）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;压缩算法对应AVFoundtaion框架里面的AudioFormatID&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;色彩二次抽样&quot;&gt;&lt;a href=&quot;#色彩二次抽样&quot; class=&quot;headerlink&quot; title=&quot;色彩二次抽样&quot;&gt;&lt;/a&gt;色彩二次抽样&lt;/h2&gt;&lt;p&gt;1）色彩二次抽样的目的是减少图片体积（通过减少样本数来实现）&lt;/p&gt;
&lt;p&gt;2）色彩二次抽样原理：人的眼睛对亮度非常敏感，但是对色彩信息比较迟钝。色彩二次抽样是指在原有的图片样本中，二次抽样，减少对色彩信息的抽样，而达到减小图片体积（样本数减小），又不怎么影响图片质量（眼睛对色彩不敏感）的效果。&lt;/p&gt;
&lt;p&gt;3）颜色模型：视频数据使用的是YCbCr&lt;/p&gt;
&lt;p&gt;4）YCbCr也称为YUV。其中Y表示亮度分量，Cb表示蓝色分量，Cr表示红色分量。&lt;/p&gt;
&lt;p&gt;5）常用的YCbCr有4:4:4、4:2:2、4:2:0、4:1:1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;4:4:4 亮度和色彩信息的比值为1:1，所有色彩信息都会被抽样，也就是全彩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4:2:2 亮度和色彩信息的比值为2:1，只有1/2的色彩信息被抽样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4:2:0和4:1:1 亮度和色彩信息比值为4:1，只有1/4的色彩信息被抽样（这种体积应该是最小）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6）色彩二次抽样对应AVFoundtaion框架里面的CVImageBuffer&lt;/p&gt;
&lt;p&gt;7）实际应用：一些特别专业的相机可能会用到4:4:4参数捕捉图片，大部分情况下会用4:2:2参数，普通的摄像头（如：iPhone摄像头）一般都是4:2:0、4:1:1&lt;/p&gt;
&lt;h2 id=&quot;H-264&quot;&gt;&lt;a href=&quot;#H-264&quot; class=&quot;headerlink&quot; title=&quot;H.264&quot;&gt;&lt;/a&gt;H.264&lt;/h2&gt;&lt;p&gt;1) H.264是编解码器的标准；编解码器是用来进行压缩和解压的；是用来压缩音视频体积的；&lt;/p&gt;
&lt;p&gt;2）H.264对应AVFoundtaion框架里面的AVVideoSettings&lt;/p&gt;
&lt;p&gt;3）H.264实现原理：H.264通过空间和时间2个维度来压缩体积：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间：空间上的压缩独立于视频帧，也称为帧内压缩。主要通过压缩图片的方式（如色彩二次抽样等）来减小体积，帧内压缩一般为有损压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;h6 id=&quot;参考链接&quot;&gt;&lt;a href=&quot;#参考链接&quot; class=&quot;headerlink&quot; title=&quot;参考链接&quot;&gt;&lt;/a&gt;参考链接&lt;/h6&gt;&lt;p&gt;1.&lt;a href=&quot;http://www.jianshu.com/p/485e946f80b4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/485e946f80b4&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;音频采样&quot;&gt;&lt;a href=&quot;#音频采样&quot; class=&quot;headerlink&quot; title=&quot;音频采样&quot;&gt;&lt;/a&gt;音频采样&lt;/h2&gt;&lt;p&gt;1）低采样率&lt;/p&gt;
&lt;p&gt;2）高采样率&lt;/p&gt;
&lt;p&gt;3）采样率（采样的次数）越高，波形越接近原波形，不过采样的次数增多，
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-NSString</title>
    <link href="williamliuwen.cn/2016/05/12/AWblog/2016/5/iOS-NSString/"/>
    <id>williamliuwen.cn/2016/05/12/AWblog/2016/5/iOS-NSString/</id>
    <published>2016-05-12T12:25:49.000Z</published>
    <updated>2016-08-13T13:34:06.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;NSString功能介绍&quot;&gt;&lt;a href=&quot;#NSString功能介绍&quot; class=&quot;headerlink&quot; title=&quot;NSString功能介绍&quot;&gt;&lt;/a&gt;NSString功能介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;NSString 截取&lt;/li&gt;
&lt;li&gt;NSString 删除所有的空格&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;NSString常用代码&quot;&gt;&lt;a href=&quot;#NSString常用代码&quot; class=&quot;headerlink&quot; title=&quot;NSString常用代码&quot;&gt;&lt;/a&gt;NSString常用代码&lt;/h2&gt;&lt;h6 id=&quot;1-NSString-截取&quot;&gt;&lt;a href=&quot;#1-NSString-截取&quot; class=&quot;headerlink&quot; title=&quot;1.NSString 截取&quot;&gt;&lt;/a&gt;1.NSString 截取&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *id1String = [self.localid.text substringWithRange:NSMakeRange(0, 2)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSRange range = [string rangeOfString:subString]; //返回&amp;#123;-1,0&amp;#125;表示找不到&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString  *a = @&amp;quot;i like long dress&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *C = [a substringToIndex:4];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;2-NSString-删除所有的空格&quot;&gt;&lt;a href=&quot;#2-NSString-删除所有的空格&quot; class=&quot;headerlink&quot; title=&quot;2.NSString 删除所有的空格&quot;&gt;&lt;/a&gt;2.NSString 删除所有的空格&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSString *)deleteSpace&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableString *strM = [NSMutableString stringWithString:self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[strM replaceOccurrencesOfString:@&amp;quot; &amp;quot; withString:@&amp;quot;&amp;quot; options:NSLiteralSearch range:NSMakeRange(0, strM.length)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return [strM copy];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;3-NSString-拼接&quot;&gt;&lt;a href=&quot;#3-NSString-拼接&quot; class=&quot;headerlink&quot; title=&quot;3.NSString 拼接&quot;&gt;&lt;/a&gt;3.NSString 拼接&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *string = it;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *newString = [string stringByAppendingString:@&amp;quot;Love&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newString = [NSString stringWithFormat:@&amp;quot;%@%@&amp;quot;, string1, string2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;newString = [NSString stringByAppendingFormat:@&amp;quot;%@ %@&amp;quot;, str1, str2];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;4-NSString-判断空-相等&quot;&gt;&lt;a href=&quot;#4-NSString-判断空-相等&quot; class=&quot;headerlink&quot; title=&quot;4.NSString 判断空 相等&quot;&gt;&lt;/a&gt;4.NSString 判断空 相等&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;if ([text lenght] == 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL isEqual = [str1 isEqualToString:str2];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;5-NSString-前缀-后缀&quot;&gt;&lt;a href=&quot;#5-NSString-前缀-后缀&quot; class=&quot;headerlink&quot; title=&quot;5.NSString 前缀 后缀&quot;&gt;&lt;/a&gt;5.NSString 前缀 后缀&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;BOOL isPrefix = [webSite hasPrefix: @&amp;quot;www.&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL isSubfix = [website hasSuffix: @&amp;quot;.cn&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;6-NSString-替换&quot;&gt;&lt;a href=&quot;#6-NSString-替换&quot; class=&quot;headerlink&quot; title=&quot;6.NSString 替换&quot;&gt;&lt;/a&gt;6.NSString 替换&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *newString =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[string stringByReplacingOccurrencesOfString:@&amp;quot;a&amp;quot; withString:@&amp;quot;b&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;7-NSString-多行书写&quot;&gt;&lt;a href=&quot;#7-NSString-多行书写&quot; class=&quot;headerlink&quot; title=&quot;7.NSString 多行书写&quot;&gt;&lt;/a&gt;7.NSString 多行书写&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *str1 = @&amp;quot;SELECT [CustomerID], [CustomerName] &amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;FROM [Customer] &amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;WHERE [CustomerID] = 1234&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *str2 = @&amp;quot;SELECT [CustomerID], [CustomerName] \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FROM [Customer] \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WHERE [CustomerID] = 1234&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;结果都是：SELECT [CustomerID], [CustomerName] FROM [Customer] WHERE [CustomerID] = 1234&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;8-NSString-删除首尾的空格和换行符&quot;&gt;&lt;a href=&quot;#8-NSString-删除首尾的空格和换行符&quot; class=&quot;headerlink&quot; title=&quot;8.NSString 删除首尾的空格和换行符&quot;&gt;&lt;/a&gt;8.NSString 删除首尾的空格和换行符&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//whitespaceAndNewlineCharacterSet去除前后的空格和换行符&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//whitespaceCharacterSet 去除前后的空格,实际效果来看只实现了去除首字母前面的空格&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *theString = @&amp;quot;   one     two three  &amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *trimmed1 = [theString stringByTrimmingCharactersInSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[NSCharacterSetwhitespaceAndNewlineCharacterSet]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *trimmed2 = [theString stringByTrimmingCharactersInSet:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[NSCharacterSetwhitespaceCharacterSet]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;9-NSString-写入文件&quot;&gt;&lt;a href=&quot;#9-NSString-写入文件&quot; class=&quot;headerlink&quot; title=&quot;9.NSString 写入文件&quot;&gt;&lt;/a&gt;9.NSString 写入文件&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *string = @&amp;quot;JackJack989878&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *filePath = @&amp;quot;/Users/apple/Desktop/my.txt&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[string writeToFile:filePath atomically:YES encoding:NSUTF8StringEncoding error:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  其中的yes表示如果传入的过程中出现错误则撤销,不会生成my.txt文件，如果是NO，则会继续生成文件my.txt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSURL *url = [NSURL fileURLWithPath:@&amp;quot;/Users/apple/Desktop/my2.txt&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[string writeToURL:url atomically:YES encoding:NSUTF8StringEncoding error:nil];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;10-NSString-大写-小写&quot;&gt;&lt;a href=&quot;#10-NSString-大写-小写&quot; class=&quot;headerlink&quot; title=&quot;10.NSString 大写 小写&quot;&gt;&lt;/a&gt;10.NSString 大写 小写&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString * str8 = @&amp;quot;baidu&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString * str9 = [str8 uppercaseString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString * str10 = @&amp;quot;CHINA&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString * str11 = [str10 lowercaseString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString * str12 = @&amp;quot;i386&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString * str12 = [str10 capitalizedString];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;11-NSString-文件扩展名&quot;&gt;&lt;a href=&quot;#11-NSString-文件扩展名&quot; class=&quot;headerlink&quot; title=&quot;11.NSString 文件扩展名&quot;&gt;&lt;/a&gt;11.NSString 文件扩展名&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *filename = @&amp;quot;11111.txt&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *fileExtension = [filename pathExtension];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;12-NSString-判断是否为整型&quot;&gt;&lt;a href=&quot;#12-NSString-判断是否为整型&quot; class=&quot;headerlink&quot; title=&quot;12.NSString 判断是否为整型&quot;&gt;&lt;/a&gt;12.NSString 判断是否为整型&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)isPureInt:(NSString*)string&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSScanner* scan = [NSScanner scannerWithString:string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return[scan scanInt:&amp;amp;val] &amp;amp;&amp;amp; [scan isAtEnd];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;13-NSString-判断是否为浮点型&quot;&gt;&lt;a href=&quot;#13-NSString-判断是否为浮点型&quot; class=&quot;headerlink&quot; title=&quot;13.NSString 判断是否为浮点型&quot;&gt;&lt;/a&gt;13.NSString 判断是否为浮点型&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)isPureFloat:(NSString*)string&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSScanner* scan = [NSScanner scannerWithString:string];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;float val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return[scan scanFloat:&amp;amp;val] &amp;amp;&amp;amp; [scan isAtEnd];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;14-NSString-将URL内容字符串&quot;&gt;&lt;a href=&quot;#14-NSString-将URL内容字符串&quot; class=&quot;headerlink&quot; title=&quot;14.NSString 将URL内容字符串&quot;&gt;&lt;/a&gt;14.NSString 将URL内容字符串&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSURL *url = [NSURLURLWithString:@&amp;quot;http://www.baidu.com&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *pageContents  = [NSString stringWithContentsOfURL:url];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;15-NSMutableString-拼接&quot;&gt;&lt;a href=&quot;#15-NSMutableString-拼接&quot; class=&quot;headerlink&quot; title=&quot;15.NSMutableString 拼接&quot;&gt;&lt;/a&gt;15.NSMutableString 拼接&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[mutableString appendString:@&amp;quot;11 12 13&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[mutableString appendString:string2];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//注意：NSString使用的是stringByAppendString:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//NSMutableString使用的是appendString:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;16-NSMutableString-截取&quot;&gt;&lt;a href=&quot;#16-NSMutableString-截取&quot; class=&quot;headerlink&quot; title=&quot;16.NSMutableString 截取&quot;&gt;&lt;/a&gt;16.NSMutableString 截取&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSRange *range = [mutableString rangeOfString:@&amp;quot;is&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;17-NSMutableString-删除&quot;&gt;&lt;a href=&quot;#17-NSMutableString-删除&quot; class=&quot;headerlink&quot; title=&quot;17.NSMutableString 删除&quot;&gt;&lt;/a&gt;17.NSMutableString 删除&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[mutableString deleteCharactersInRange:range];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;18-NSMutableString-插入&quot;&gt;&lt;a href=&quot;#18-NSMutableString-插入&quot; class=&quot;headerlink&quot; title=&quot;18.NSMutableString 插入&quot;&gt;&lt;/a&gt;18.NSMutableString 插入&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[mutableString insetString:@&amp;quot;15&amp;quot; atIndex:4];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h6 id=&quot;19-NSMutableString-替换&quot;&gt;&lt;a href=&quot;#19-NSMutableString-替换&quot; class=&quot;headerlink&quot; title=&quot;19.NSMutableString 替换&quot;&gt;&lt;/a&gt;19.NSMutableString 替换&lt;/h6&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableString * str=[[NSMutableString alloc]initWithFormat:@&amp;quot;1,1,1,1,1,1&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray * array=[NSMutableArray arrayWithArray:[str componentsSeparatedByString:@&amp;quot;,&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[array replaceObjectAtIndex:4 withObject:@&amp;quot;2&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NSString功能介绍&quot;&gt;&lt;a href=&quot;#NSString功能介绍&quot; class=&quot;headerlink&quot; title=&quot;NSString功能介绍&quot;&gt;&lt;/a&gt;NSString功能介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;NSString 截取&lt;/li&gt;
&lt;li&gt;NSString 删除所有的空格&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-Quartz2D</title>
    <link href="williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-Quartz2D/"/>
    <id>williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-Quartz2D/</id>
    <published>2016-05-11T13:51:16.000Z</published>
    <updated>2016-08-13T13:34:12.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Quartz2D可以用来做什么？&quot;&gt;&lt;a href=&quot;#Quartz2D可以用来做什么？&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D可以用来做什么？&quot;&gt;&lt;/a&gt;Quartz2D可以用来做什么？&lt;/h2&gt;&lt;p&gt;1.什么是Quartz2D？（用来绘图的）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Quartz 2D是一个二维绘图引擎，同时支持iOS和Mac系统（所以代码可以在ios和mac系统运行）；Quartz 2D 是基于C语言的API接口；数据类型和函数基本都以CG作为前缀&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.实际中怎么应用Quartz2D？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;可以自定义UI控件，iOS中大部分控件的内容都是通过Quartz2D画出来的，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绘制图形 : 线条\三角形\矩形\圆\弧等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绘制文字；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绘制\生成图片(图像)；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;读取\生成PDF；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;截图\裁剪图片；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;手势开锁&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.Quartz2D常用名词&lt;/p&gt;
&lt;p&gt;1）图形上下文&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;图形上下文是一个CGContextRef类型的数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图形上下文的作用：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;保存绘图信息、绘图状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;决定绘制的输出目标（绘制到什么地方去？）（输出目标可以是PDF文件、Bitmap或者显示器的窗口上）相同的一套绘图序列，指定不同的Graphics Context，就可将相同的图像绘制到不同的目标上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;五种图形上下文：1. Bitmap Graphics Context 2. PDF Graphics Context 3. Window Graphics Context 4. Layer Graphics Context 5. Printer Graphics Context&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;图形上下文必须跟view相关联，才能将内容绘制到view上面&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;绘图顺序（如果在同一个图形上下文上，后绘制的图形会覆盖前面绘制的图形上面）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）图形上下文栈&lt;/p&gt;
&lt;p&gt;3）Quartz2D的内存管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用含有“Create”或“Copy”或”retain”的函数创建的对象，使用完后必须释放，否则将导致内存泄露&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用不含有“Create”或“Copy”的函数获取的对象，则不需要释放&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果retain了一个对象，不再使用时，需要将其release掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;以使用Quartz 2D的函数来指定retain和release一个对象。例如，如果创建了一个CGColorSpace对象，则使用函数CGColorSpaceRetain和CGColorSpaceRelease来retain和release对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;也可以使用Core Foundation的CFRetain和CFRelease。注意不能传递NULL值给这些函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;drawRect-方法的作用？&quot;&gt;&lt;a href=&quot;#drawRect-方法的作用？&quot; class=&quot;headerlink&quot; title=&quot;drawRect:方法的作用？&quot;&gt;&lt;/a&gt;drawRect:方法的作用？&lt;/h2&gt;&lt;p&gt;1.在drawRect:方法中才能取得跟view相关联的图形上下文&lt;/p&gt;
&lt;p&gt;2.View内部有个layer（图层）属性，drawRect:方法中取得的是一个Layer Graphics Context，因此，绘制的东西其实是绘制到view的layer上去了；&lt;/p&gt;
&lt;p&gt;3.View之所以能显示东西，完全是因为它内部的layer&lt;/p&gt;
&lt;p&gt;4.drawRect方法调用的时机：（当view第一次显示到屏幕上时（被加到UIWindow上显示出来）调用view的setNeedsDisplay或者setNeedsDisplayInRect:时）&lt;/p&gt;
&lt;h2 id=&quot;Quartz2D绘图步骤&quot;&gt;&lt;a href=&quot;#Quartz2D绘图步骤&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D绘图步骤&quot;&gt;&lt;/a&gt;Quartz2D绘图步骤&lt;/h2&gt;&lt;p&gt;1.拼接路径函数&lt;/p&gt;
&lt;p&gt;2.绘制路径函数&lt;/p&gt;
&lt;p&gt;3.例子:创建一条线段&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 第一步：新建一个类，继承自UIView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 第二步：实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)drawRect:(CGRect)rect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 第三步：获取图形上下文（Graphics Context）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef ctx = UIGraphicsGetCurrentContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 第四步：拼接路径（下面代码是搞一条线段）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextMoveToPoint(ctx, 10, 10);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextAddLineToPoint(ctx, 100, 100);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 第五步：渲染图形，显示到view上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextStrokePath(ctx);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 或者填充&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextFillPath(ctx);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Quartz2D绘图–拼接路径函数&quot;&gt;&lt;a href=&quot;#Quartz2D绘图–拼接路径函数&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D绘图–拼接路径函数&quot;&gt;&lt;/a&gt;Quartz2D绘图–拼接路径函数&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 新建一个起点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextMoveToPoint(CGContextRef c, CGFloat x, CGFloat y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 添加新的线段到某个点(到某个点的一条线)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddLineToPoint(CGContextRef c, CGFloat x, CGFloat y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 添加一个矩形&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddRect(CGContextRef c, CGRect rect)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 添加一个椭圆&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddEllipseInRect(CGContextRef context, CGRect rect)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 添加一个圆弧&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddArc(CGContextRef c, CGFloat x, CGFloat y, CGFloat radius, CGFloat startAngle, CGFloat endAngle, int clockwise)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Quartz2D绘图–绘制路径函数&quot;&gt;&lt;a href=&quot;#Quartz2D绘图–绘制路径函数&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D绘图–绘制路径函数&quot;&gt;&lt;/a&gt;Quartz2D绘图–绘制路径函数&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Mode参数决定绘制的模式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextDrawPath(CGContextRef c, CGPathDrawingMode mode)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 绘制空心路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextStrokePath(CGContextRef c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 绘制实心路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextFillPath(CGContextRef c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;提示：一般以CGContextDraw、CGContextStroke、CGContextFill开头的函数，都是用来绘制路径的&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Quartz2D绘图–transform属性&quot;&gt;&lt;a href=&quot;#Quartz2D绘图–transform属性&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D绘图–transform属性&quot;&gt;&lt;/a&gt;Quartz2D绘图–transform属性&lt;/h2&gt;&lt;p&gt;1.利用transform属性可以修改控件的位移（位置）、缩放、旋转&lt;/p&gt;
&lt;p&gt;2.创建一个transform属性&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGAffineTransform CGAffineTransformMakeTranslation(CGFloat tx,CGFloat ty);位移&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGAffineTransform CGAffineTransformMakeScale(CGFloat sx,CGFloat sy);缩放&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGAffineTransform CGAffineTransformMakeRotation(CGFloat angel);旋转&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意：这里angle是弧度制，不是角度制，就用用pi值表示，一个pi就是180度；45度就是4分之1 pi；在代码中用M_PI_4表示&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.在某个transform的基础上进行叠加；&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGAffineTransform CGAffineTransformTranslation(CGAffineTransform,CGFloat tx,CGFloat ty);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGAffineTransform CGAffineTransformScale(CGAffineTransform,CGFloat sx,CGFloat sy);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGAffineTransform CGAffineTransformRotation(CGAffineTransform ,CGFloat angel);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意这里的方法比上面少了Make在里面；&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4.transform常用的3个方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;对控件进行缩放： CGAffineTransformScale&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对控件进行位移； CGAffineTransformTranslate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对控件进行旋转； CGAffineTransformRotate&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;Quartz2D绘图–CGRect-CGPoint-CGSize-属性&quot;&gt;&lt;a href=&quot;#Quartz2D绘图–CGRect-CGPoint-CGSize-属性&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D绘图–CGRect \ CGPoint \ CGSize 属性&quot;&gt;&lt;/a&gt;Quartz2D绘图–CGRect \ CGPoint \ CGSize 属性&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;CGRect=NSRect&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CGPoint=NSPoint&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CGSize=NSSize 修改控件的位置和尺寸&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改控件位置的有: frame.origin 、 center&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改控件尺寸的有: frame.size 、 bounds.size&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.CGRect、NSRect&lt;/p&gt;
&lt;p&gt;1) NSRect\CGRect是NSPoint\CGPoint和NSSize\CGSize的一个组合；表示的是坐标和尺寸； NSRect(NSPoint NSSize)、CGRect(CGPoint CGSize)&lt;/p&gt;
&lt;p&gt;2) 可以通过CGRectMake和NSMakeRect方法创建CGRect和NSRect对象；&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect rect = CGRectMake(0,0,100,50); // 表示原点的位置和元素上下的尺寸；&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3) 通过结构体成员变量打印CGRect的成员数值：CGRect rect = CGRectMake(0,0,100,50);&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;x=%f,y=%f,width=%f,height=%f&amp;quot;,rect.origin.x,rect.origin.y,rect.size.width,rect.size.height);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4) 创建CGRect对象的其他方式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect rect = &amp;#123;&amp;#123;0,0&amp;#125;,&amp;#123;100,50&amp;#125;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect rect = &amp;#123;point1,size1&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5) 比较两个CGRect是否相等：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRectEqualToRect(CGRect rect1,CGRect rect2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;6) 判断CGPoint中是否在CGRect的范围中：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL b = CGRectContainsPoint(CGRect rect,CGPoint point);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  这个方法包含在CoreGraphics framework框架中,所以需要引入这个框架； #import &amp;lt;CoreGraphics/CoreGraphics.h&amp;gt;;注意： 方法的声明都在Foundation框架里面但是定义都在CoreGraphics的框架里面&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;7) 将结构体转换为字符串的操作：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *str = NSStringFromPoint(point1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *str = NSStringFromSize(size1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *str = NSStringFromRect(rect1);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.CGPoint、NSPoint&lt;/p&gt;
&lt;p&gt;1) 本质上是表示点元素坐标位置的结构体；其中CGPoint比较常用，因为它具有跨平台性；&lt;/p&gt;
&lt;p&gt;2) 创建对象的方法有：NSMakePoint 、 CGPointMake;开发中CGPointMake比较常用；&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSPoint p2 = NSMakePoint(20,20)/CGPointMake(20,20);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3) 比较两个点是否相同：BOOL b = CGPoingEqualToPoint(CGPointMake(10,10),CGPointMake(10,10));&lt;/p&gt;
&lt;p&gt;4) 注意：在iOS开发中，原点的坐标是在左上角；使用CGPoingZero可以表示；相当于CGPoingMake(0,0);&lt;/p&gt;
&lt;p&gt;3.CGSize、NSSize&lt;/p&gt;
&lt;p&gt;1) 表示用户界面元素的尺寸；&lt;/p&gt;
&lt;p&gt;2) 创建对象的方法是：CGSizeMake和NSMakeSize方法；开发中主要使用CGSizeMake;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSSize s1/CGSize s1= CGSizeMake(100,50)/NSMakeSize(100,50);//左面数值是宽，右面是高&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3) 比较两个元素尺寸是否相等：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BOOL a = CGSizeEqualToSize(CGSize size1,CGSize size2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4)  CGSizeZero表示CGSizeMake(0,0),表示这个对象的上下尺寸都是0。&lt;/p&gt;
&lt;h2 id=&quot;Quartz2D绘图–简单用法&quot;&gt;&lt;a href=&quot;#Quartz2D绘图–简单用法&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D绘图–简单用法&quot;&gt;&lt;/a&gt;Quartz2D绘图–简单用法&lt;/h2&gt;&lt;p&gt;1.创建一个点&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Points：指定一个点成为current point，Quartz会跟踪current point一般执行完一个相关函数后，current point都会相应的改变.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextMoveToPoint (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.创建一条线&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Lines：相关的几个函数，创建一条直线，从current point到 (x,y)，然后current point会变成(x,y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddLineToPoint (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat x,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.创建多条线&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 创建多条直线，比如points有两个点，那么会画两条直线 从current point到 (x1,y1),然后是(x1,y1)到(x2,y2)，然后current point会变成points中的最后一个点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddLines (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const CGPoint points[],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size_t count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;4.画一条圆弧&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;两种方法创建弧度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 第一种: 假如想创建一个完整的圆圈，那么 开始弧度就是0 结束弧度是 2pi， 因为圆周长是 2pir.最后，函数执行完后，current point就被重置为(x,y).还有一点要注意的是，假如当前path已经存在一个subpath，那么这个函数执行的另外一个效果是会有一条直线，从current point到弧的起点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddArc (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat x,             //圆心的x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat y,    //圆心的x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat radius,   //圆的半径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat startAngle,    //开始弧度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat endAngle,   //结束弧度&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int clockwise          //0表示顺时针，1表示逆时针&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 第二种: 首先画两条线，这两条线分别是 current point to (x1,y1) 和(x1,y1) to (x2,y2).这样就是出现一个以(x1,y1)为顶点的两条射线，然后定义半径长度，这个半径是垂直于两条射线的，这样就能决定一个圆了，更好的理解看下图，不过个人认为下图所标的 tangent point 1的位置是错误的.最后，函数执行完后，current point就被重置为(x2,y2).还有一点要注意的是，假如当前path已经存在一个subpath，那么这个函数执行的另外一个效果是会有一条直线，从current point到(x1,y1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddArcToPoint (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat x1,  //端点1的x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat y1,  //端点1的y坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat x2,  //端点2的x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat y2,  //端点2的y坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat radius //半径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;5.画曲线&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Curves:画曲线，一般是一条直线，然后定义几个控制点，使直线变弯曲。三次曲线函数;假如第二个控制点（cp2x，cp2y）比（cp1x,cp1y） 更接近current point，那么会形成一个封闭的曲线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddCurveToPoint (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat cp1x, //控制点1 x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat cp1y, //控制点1 y坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat cp2x, //控制点2 x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat cp2y, //控制点2 y坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat x,  //直线的终点 x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat y  //直线的终点 y坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 二次曲线函数;执行完函数貌似current point不会变化，没有具体测试过&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddQuadCurveToPoint (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat cpx,  //控制点 x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat cpy,  //控制点 y坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat x,  //直线的终点 x坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat y  //直线的终点 y坐标&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;6.画圆&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Ellipses：如果矩形是一个正方形，那么画出来就是一个圆，执行完函数貌似current point不会变化，没有具体测试过&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddEllipseInRect (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef context,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect rect  //一矩形&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;7.画三角形&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Rectangles&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddRect (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect rect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 一次性画出多个矩形：需要注意的是，画矩形有一些特别，current point没有发生变化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void CGContextAddRects (&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGContextRef c,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const CGRect rects[],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;size_t count&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Quartz2D绘图–CALayer&quot;&gt;&lt;a href=&quot;#Quartz2D绘图–CALayer&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D绘图–CALayer&quot;&gt;&lt;/a&gt;Quartz2D绘图–CALayer&lt;/h2&gt;&lt;p&gt;1.CALayer图层的组成&lt;/p&gt;
&lt;p&gt;1）CAMediaTiming&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.duration&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2）CAAnimation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;.timing Function&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.delegate&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3) CAAnimationGroup&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.animations&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4) CAPropertyAnimation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.keypath&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5) CABasicAnimation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;.fromValue&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.toValue&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6) CAKeyFramAnimation&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;.Values&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.Path&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;.KeyTimes&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;7) CATransition&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.filter&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Quartz2D可以用来做什么？&quot;&gt;&lt;a href=&quot;#Quartz2D可以用来做什么？&quot; class=&quot;headerlink&quot; title=&quot;Quartz2D可以用来做什么？&quot;&gt;&lt;/a&gt;Quartz2D可以用来做什么？&lt;/h2&gt;&lt;p&gt;1.什么是Quartz2D？
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-Wifi</title>
    <link href="williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-Wifi/"/>
    <id>williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-Wifi/</id>
    <published>2016-05-11T12:45:03.000Z</published>
    <updated>2016-08-13T13:34:22.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;Wifi介绍&quot;&gt;&lt;a href=&quot;#Wifi介绍&quot; class=&quot;headerlink&quot; title=&quot;Wifi介绍&quot;&gt;&lt;/a&gt;Wifi介绍&lt;/h2&gt;&lt;p&gt;1.是一个创建于IEEE 802.11标准的无线局域网技术&lt;/p&gt;
&lt;p&gt;2.利用wifi连接的设备处在一个局域网内，通过IP地址互相通信&lt;/p&gt;
&lt;p&gt;3.wifi能上网，是因为提供wifi的路由器具有路由网关的功能&lt;/p&gt;
&lt;p&gt;4.Ad hoc，Wi-Fi无线通信也可以不需通过接入点，直接从一台电脑传出到另一台。&lt;/p&gt;
&lt;p&gt;5.IOS下的Ad Hoc是指在不发布到App Store的情况下，可以将发布状态下的App装在指定的一些真机上进行测试，但是这里指定的设备数量是有限的（99台）是解决如何在不提交app应用的情况下，使用ad-hoc模式来验证消息推送(push notifications).&lt;/p&gt;
&lt;p&gt;6.Ad Hoc Distribution: 针对测试设备, 每个应用不能发不到超过100个设备上,发布前需要将每个设备的唯一编码打包进去&lt;/p&gt;
&lt;p&gt;7.Wi-Fi的设置至少需要一个接入点（Access Point，AP）和一个或一个以上的客户端用户（client）。&lt;/p&gt;
&lt;p&gt;8.无线AP每100ms将SSID（Service Set Identifier）经由beacons（信号台）数据包广播一次，beacons数据包的传输速率是1 Mbit/s，并且长度相当的短，所以这个广播动作对网络性能的影响不大。&lt;/p&gt;
&lt;p&gt;9.因为Wi-Fi规定的最低传输速率是1 Mbit/s，所以确保所有的Wi-Fi client端都能收到这个SSID广播数据包，client可以借此决定是否要和这一个SSID的AP连接。&lt;/p&gt;
&lt;p&gt;10.用户可以设置要连接到哪一个SSID。Wi-Fi系统开放对客户端的连接并支持漫游，这就是Wi-Fi的好处。但亦意味着，一个无线适配器有可能在性能上优于其他的适配器。由于Wi-Fi通过空气传送信号，所以和非交换以太网路有相同的特点。&lt;/p&gt;
&lt;p&gt;11.近两年，出现一种WIFI over cable的新方案。此方案属于EOC（ethernet over cable）中的一种技术。通过将2.4G wifi射频降频后在cable中传输。此种方案已经在中国小范围内测试商用。&lt;/p&gt;
&lt;h2 id=&quot;Wifi在智能家居上的应用&quot;&gt;&lt;a href=&quot;#Wifi在智能家居上的应用&quot; class=&quot;headerlink&quot; title=&quot;Wifi在智能家居上的应用&quot;&gt;&lt;/a&gt;Wifi在智能家居上的应用&lt;/h2&gt;&lt;p&gt;1.智能家居接入路由。手机接入同一个路由，这是前提。然后 手机和家居分别上报自己接入路由的bssid 和ssid ，由服务器进行匹配.&lt;/p&gt;
&lt;p&gt;2.实际上bssid 就是mac地址，这玩意儿不会重复。ssid 就是名称，这样经服务器匹配之后，下发给手机，然后显示同一路由下的接入的目标设备，并把设备的ip以及相关信息比如设备名下发给手机端显示&lt;/p&gt;
&lt;p&gt;3.手机—–路由器——智能设备&lt;/p&gt;
&lt;p&gt;4.iOS设备间可以使用AirDrop (UIActivityViewController类)&lt;/p&gt;
&lt;p&gt;5.MultipeerConnectivity 框架，距离较近的Apple设备（iMac/iPad/iPhone）之间可基于蓝牙和WiFi（P2P WiFi）技术进行发现和连接实现近场通信&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Wifi介绍&quot;&gt;&lt;a href=&quot;#Wifi介绍&quot; class=&quot;headerlink&quot; title=&quot;Wifi介绍&quot;&gt;&lt;/a&gt;Wifi介绍&lt;/h2&gt;&lt;p&gt;1.是一个创建于IEEE 802.11标准的无线局域网技术&lt;/p&gt;
&lt;p&gt;2.利用wifi连接的设备处在一个
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-Instruments</title>
    <link href="williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-Instruments/"/>
    <id>williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-Instruments/</id>
    <published>2016-05-11T11:37:04.000Z</published>
    <updated>2016-08-13T13:33:49.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;测试工具Instruments&quot;&gt;&lt;a href=&quot;#测试工具Instruments&quot; class=&quot;headerlink&quot; title=&quot;测试工具Instruments&quot;&gt;&lt;/a&gt;测试工具Instruments&lt;/h2&gt;&lt;h2 id=&quot;测试分类&quot;&gt;&lt;a href=&quot;#测试分类&quot; class=&quot;headerlink&quot; title=&quot;测试分类&quot;&gt;&lt;/a&gt;测试分类&lt;/h2&gt;&lt;p&gt;一、单元测试：某方法函数的测试；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.继承类；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.写测试代码；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3.重要概念：断言/猜测/估计（XCTAssertEqual断言等于；XCTAssertTrue断言为真；XCTAssertNil断言为空；除了上面两个方法还有更多）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4.单元测试颜色：红色失败，绿色通过；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5.单元测试好处：a.轻量级测试，针对某个方法；b.发布程序的时候不会被打包；c.不需要启动程序；d.可以给每一个类创建一个继承单元测试类的测试方法；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;6.单元测试用处：一般用在业务逻辑&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二、集群测试：所有功能的测试；&lt;/p&gt;
&lt;p&gt;三、压力测试：大批量用户的测试；&lt;/p&gt;
&lt;h2 id=&quot;测试APP&quot;&gt;&lt;a href=&quot;#测试APP&quot; class=&quot;headerlink&quot; title=&quot;测试APP&quot;&gt;&lt;/a&gt;测试APP&lt;/h2&gt;&lt;p&gt;1.使用苹果自带的TestFlight&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;测试工具Instruments&quot;&gt;&lt;a href=&quot;#测试工具Instruments&quot; class=&quot;headerlink&quot; title=&quot;测试工具Instruments&quot;&gt;&lt;/a&gt;测试工具Instruments&lt;/h2&gt;&lt;h2 id=&quot;测试分类&quot;&gt;&lt;a href
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS-NSLog</title>
    <link href="williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-NSLog/"/>
    <id>williamliuwen.cn/2016/05/11/AWblog/2016/5/iOS-NSLog/</id>
    <published>2016-05-11T11:33:15.000Z</published>
    <updated>2016-08-13T13:33:59.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;为什么使用NSLog，而不用Printf&quot;&gt;&lt;a href=&quot;#为什么使用NSLog，而不用Printf&quot; class=&quot;headerlink&quot; title=&quot;为什么使用NSLog，而不用Printf()&quot;&gt;&lt;/a&gt;为什么使用NSLog，而不用Printf()&lt;/h2&gt;&lt;p&gt;1.打印输出使用 NSLog() 而不是 println() 呢？&lt;/p&gt;
&lt;p&gt;2.原因是使用 print() / println() 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。&lt;/p&gt;
&lt;p&gt;3.print()会把需要输出的每个字符一个一个的输出到控制台&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;4.普通使用并没有问题，可是当多线程同步输出的时候问题就来了，由于很多 println() 同时打印，就会导致控制台上的字符混乱的堆在一起，而NSLog() 就没有这个问题&lt;/p&gt;
&lt;h2 id=&quot;NSLog格式&quot;&gt;&lt;a href=&quot;#NSLog格式&quot; class=&quot;headerlink&quot; title=&quot;NSLog格式&quot;&gt;&lt;/a&gt;NSLog格式&lt;/h2&gt;&lt;p&gt;%@     对象&lt;/p&gt;
&lt;p&gt;%i     整数&lt;/p&gt;
&lt;p&gt;%d,    double&lt;/p&gt;
&lt;p&gt;%u     无符整形&lt;/p&gt;
&lt;p&gt;%f     浮点/双字&lt;/p&gt;
&lt;p&gt;%x, %X 二进制整数&lt;/p&gt;
&lt;p&gt;%o     八进制整数&lt;/p&gt;
&lt;p&gt;%zu    size_t&lt;/p&gt;
&lt;p&gt;%p     指针&lt;/p&gt;
&lt;p&gt;%e     浮点/双字 （科学计算）&lt;/p&gt;
&lt;p&gt;%g     浮点/双字&lt;/p&gt;
&lt;p&gt;%s     short&lt;/p&gt;
&lt;p&gt;%.*s   Pascal字符串&lt;/p&gt;
&lt;p&gt;%c     字符 char&lt;/p&gt;
&lt;p&gt;%C     unichar&lt;/p&gt;
&lt;p&gt;%lld   64位长整数（long long）&lt;/p&gt;
&lt;p&gt;%llu   无符64位长整数&lt;/p&gt;
&lt;p&gt;%Lf    64位双字&lt;/p&gt;
&lt;p&gt;%zu       size_t&lt;/p&gt;
&lt;p&gt;%#     A class object (Class)&lt;/p&gt;
&lt;p&gt;%:     A method selector (SEL)&lt;/p&gt;
&lt;p&gt;%%     打印百分号&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么使用NSLog，而不用Printf&quot;&gt;&lt;a href=&quot;#为什么使用NSLog，而不用Printf&quot; class=&quot;headerlink&quot; title=&quot;为什么使用NSLog，而不用Printf()&quot;&gt;&lt;/a&gt;为什么使用NSLog，而不用Printf()&lt;/h2&gt;&lt;p&gt;1.打印输出使用 NSLog() 而不是 println() 呢？&lt;/p&gt;
&lt;p&gt;2.原因是使用 print() / println() 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。&lt;/p&gt;
&lt;p&gt;3.print()会把需要输出的每个字符一个一个的输出到控制台&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hexo 部署</title>
    <link href="williamliuwen.cn/2016/04/23/AWblog/2016/4/hexo-%E9%83%A8%E7%BD%B2/"/>
    <id>williamliuwen.cn/2016/04/23/AWblog/2016/4/hexo-部署/</id>
    <published>2016-04-23T02:53:57.000Z</published>
    <updated>2016-08-13T13:32:49.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;部署hexo前提准备&quot;&gt;&lt;a href=&quot;#部署hexo前提准备&quot; class=&quot;headerlink&quot; title=&quot;部署hexo前提准备&quot;&gt;&lt;/a&gt;部署hexo前提准备&lt;/h4&gt;&lt;p&gt;1.到node.js 网站 &lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://nodejs.org/en/&lt;/a&gt;  下载node.js 直接安装，安装完，查看版本 ，node -v&lt;/p&gt;
&lt;p&gt;2.到homebrew 网站  &lt;a href=&quot;http://brew.sh/index_zh-cn.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://brew.sh/index_zh-cn.html&lt;/a&gt; 使用下面的命令安装,如果安装失败，使用sudo&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/usr/bin/ruby -e &amp;quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;开始部署hexo&quot;&gt;&lt;a href=&quot;#开始部署hexo&quot; class=&quot;headerlink&quot; title=&quot;开始部署hexo&quot;&gt;&lt;/a&gt;开始部署hexo&lt;/h4&gt;&lt;p&gt;1.使用下面的命令，一条一条来，如果不行，用sudo&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.直接访问本地部署好的hexo&lt;/p&gt;
&lt;h4 id=&quot;利用hexo发布文章&quot;&gt;&lt;a href=&quot;#利用hexo发布文章&quot; class=&quot;headerlink&quot; title=&quot;利用hexo发布文章&quot;&gt;&lt;/a&gt;利用hexo发布文章&lt;/h4&gt;&lt;p&gt;1.新建文章，先进入hexo文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo new &amp;quot;新文章&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.写好文章后，生成静态文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo g&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.生成静态文件后，上传到github&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;hexo d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;hexo技巧&quot;&gt;&lt;a href=&quot;#hexo技巧&quot; class=&quot;headerlink&quot; title=&quot;hexo技巧&quot;&gt;&lt;/a&gt;hexo技巧&lt;/h4&gt;&lt;p&gt;1.因为hexo生成的静态文件是放在public文件夹下面的，如果你部署github的时候，使用的git destop版本来上传代码的话，你可以clone你的git下来的时候，clone到hexo文件下，且改名为public，那么下次hexo生成静态文件的时候就会直接生成到clone下来的git文件夹里面，那你用git desktop上传代码的时候，就可以直接commit上传了&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;部署hexo前提准备&quot;&gt;&lt;a href=&quot;#部署hexo前提准备&quot; class=&quot;headerlink&quot; title=&quot;部署hexo前提准备&quot;&gt;&lt;/a&gt;部署hexo前提准备&lt;/h4&gt;&lt;p&gt;1.到node.js 网站 &lt;a href=&quot;https://nodejs.
    
    </summary>
    
    
  </entry>
  
</feed>
