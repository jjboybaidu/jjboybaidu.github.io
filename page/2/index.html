
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>JJBoy</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="JJBoy">
    

    
    <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="JJBoy">
<meta property="og:url" content="williamliuwen.cn/page/2/index.html">
<meta property="og:site_name" content="JJBoy">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JJBoy">
<meta name="twitter:description">

    
    <link rel="alternative" href="/atom.xml" title="JJBoy" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="JJBoy" title="JJBoy"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="JJBoy">JJBoy</a></h1>
				<h2 class="blog-motto">知我者谓我心忧，不知我者谓我何求。</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:williamliuwen.cn">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/11/iOS-Wifi/" title="iOS-Wifi" itemprop="url">iOS-Wifi</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="JJBoy" target="_blank" itemprop="author">JJBoy</a>
		
  <p class="article-time">
    <time datetime="2016-08-11T12:45:03.000Z" itemprop="datePublished"> Published 2016-08-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Wifi介绍"><a href="#Wifi介绍" class="headerlink" title="Wifi介绍"></a>Wifi介绍</h2><p>1.是一个创建于IEEE 802.11标准的无线局域网技术</p>
<p>2.利用wifi连接的设备处在一个局域网内，通过IP地址互相通信</p>
<p>3.wifi能上网，是因为提供wifi的路由器具有路由网关的功能</p>
<p>4.Ad hoc，Wi-Fi无线通信也可以不需通过接入点，直接从一台电脑传出到另一台。</p>
<p>5.IOS下的Ad Hoc是指在不发布到App Store的情况下，可以将发布状态下的App装在指定的一些真机上进行测试，但是这里指定的设备数量是有限的（99台）是解决如何在不提交app应用的情况下，使用ad-hoc模式来验证消息推送(push notifications).</p>
<p>6.Ad Hoc Distribution: 针对测试设备, 每个应用不能发不到超过100个设备上,发布前需要将每个设备的唯一编码打包进去</p>
<p>7.Wi-Fi的设置至少需要一个接入点（Access Point，AP）和一个或一个以上的客户端用户（client）。</p>
<p>8.无线AP每100ms将SSID（Service Set Identifier）经由beacons（信号台）数据包广播一次，beacons数据包的传输速率是1 Mbit/s，并且长度相当的短，所以这个广播动作对网络性能的影响不大。</p>
<p>9.因为Wi-Fi规定的最低传输速率是1 Mbit/s，所以确保所有的Wi-Fi client端都能收到这个SSID广播数据包，client可以借此决定是否要和这一个SSID的AP连接。</p>
<p>10.用户可以设置要连接到哪一个SSID。Wi-Fi系统开放对客户端的连接并支持漫游，这就是Wi-Fi的好处。但亦意味着，一个无线适配器有可能在性能上优于其他的适配器。由于Wi-Fi通过空气传送信号，所以和非交换以太网路有相同的特点。</p>
<p>11.近两年，出现一种WIFI over cable的新方案。此方案属于EOC（ethernet over cable）中的一种技术。通过将2.4G wifi射频降频后在cable中传输。此种方案已经在中国小范围内测试商用。</p>
<h2 id="Wifi在智能家居上的应用"><a href="#Wifi在智能家居上的应用" class="headerlink" title="Wifi在智能家居上的应用"></a>Wifi在智能家居上的应用</h2><p>1.智能家居接入路由。手机接入同一个路由，这是前提。然后 手机和家居分别上报自己接入路由的bssid 和ssid ，由服务器进行匹配.</p>
<p>2.实际上bssid 就是mac地址，这玩意儿不会重复。ssid 就是名称，这样经服务器匹配之后，下发给手机，然后显示同一路由下的接入的目标设备，并把设备的ip以及相关信息比如设备名下发给手机端显示</p>
<p>3.手机—–路由器——智能设备</p>
<p>4.iOS设备间可以使用AirDrop (UIActivityViewController类)</p>
<p>5.MultipeerConnectivity 框架，距离较近的Apple设备（iMac/iPad/iPhone）之间可基于蓝牙和WiFi（P2P WiFi）技术进行发现和连接实现近场通信</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/11/iOS-Instruments/" title="iOS-Instruments" itemprop="url">iOS-Instruments</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="JJBoy" target="_blank" itemprop="author">JJBoy</a>
		
  <p class="article-time">
    <time datetime="2016-08-11T11:37:04.000Z" itemprop="datePublished"> Published 2016-08-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="测试工具Instruments"><a href="#测试工具Instruments" class="headerlink" title="测试工具Instruments"></a>测试工具Instruments</h2><h2 id="测试分类"><a href="#测试分类" class="headerlink" title="测试分类"></a>测试分类</h2><p>一、单元测试：某方法函数的测试；</p>
<ul>
<li><p>1.继承类；</p>
</li>
<li><p>2.写测试代码；</p>
</li>
<li><p>3.重要概念：断言/猜测/估计（XCTAssertEqual断言等于；XCTAssertTrue断言为真；XCTAssertNil断言为空；除了上面两个方法还有更多）；</p>
</li>
<li><p>4.单元测试颜色：红色失败，绿色通过；</p>
</li>
<li><p>5.单元测试好处：a.轻量级测试，针对某个方法；b.发布程序的时候不会被打包；c.不需要启动程序；d.可以给每一个类创建一个继承单元测试类的测试方法；</p>
</li>
<li><p>6.单元测试用处：一般用在业务逻辑</p>
</li>
</ul>
<p>二、集群测试：所有功能的测试；</p>
<p>三、压力测试：大批量用户的测试；</p>
<h2 id="测试APP"><a href="#测试APP" class="headerlink" title="测试APP"></a>测试APP</h2><p>1.使用苹果自带的TestFlight</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/11/iOS-NSLog/" title="iOS-NSLog" itemprop="url">iOS-NSLog</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="JJBoy" target="_blank" itemprop="author">JJBoy</a>
		
  <p class="article-time">
    <time datetime="2016-08-11T11:33:15.000Z" itemprop="datePublished"> Published 2016-08-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="为什么使用NSLog，而不用Printf"><a href="#为什么使用NSLog，而不用Printf" class="headerlink" title="为什么使用NSLog，而不用Printf()"></a>为什么使用NSLog，而不用Printf()</h2><p>1.打印输出使用 NSLog() 而不是 println() 呢？</p>
<p>2.原因是使用 print() / println() 输出的话，它会简单地使用 流（stream） 的概念，学过 C++ 的都知道。</p>
<p>3.print()会把需要输出的每个字符一个一个的输出到控制台</p>
<p>4.普通使用并没有问题，可是当多线程同步输出的时候问题就来了，由于很多 println() 同时打印，就会导致控制台上的字符混乱的堆在一起，而NSLog() 就没有这个问题</p>
<h2 id="NSLog格式"><a href="#NSLog格式" class="headerlink" title="NSLog格式"></a>NSLog格式</h2><p>%@     对象</p>
<p>%i     整数</p>
<p>%d,    double</p>
<p>%u     无符整形</p>
<p>%f     浮点/双字</p>
<p>%x, %X 二进制整数</p>
<p>%o     八进制整数</p>
<p>%zu    size_t</p>
<p>%p     指针</p>
<p>%e     浮点/双字 （科学计算）</p>
<p>%g     浮点/双字</p>
<p>%s     short</p>
<p>%.*s   Pascal字符串</p>
<p>%c     字符 char</p>
<p>%C     unichar</p>
<p>%lld   64位长整数（long long）</p>
<p>%llu   无符64位长整数</p>
<p>%Lf    64位双字</p>
<p>%zu       size_t</p>
<p>%#     A class object (Class)</p>
<p>%:     A method selector (SEL)</p>
<p>%%     打印百分号</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/09/iOS-RunTime/" title="iOS-RunTime" itemprop="url">iOS-RunTime</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="JJBoy" target="_blank" itemprop="author">JJBoy</a>
		
  <p class="article-time">
    <time datetime="2016-08-08T22:02:46.000Z" itemprop="datePublished"> Published 2016-08-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="runtime常用方法"><a href="#runtime常用方法" class="headerlink" title="runtime常用方法"></a>runtime常用方法</h2><p>1.类结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">struct objc_class &#123;</span><br><span class="line">Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">#if !__OBJC2__</span><br><span class="line">Class super_class                       OBJC2_UNAVAILABLE;  // 父类</span><br><span class="line">const char *name                        OBJC2_UNAVAILABLE;  // 类名</span><br><span class="line">long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</span><br><span class="line">long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</span><br><span class="line">long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小</span><br><span class="line">struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表</span><br><span class="line">struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表</span><br><span class="line">struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存</span><br><span class="line">struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表</span><br><span class="line">#endif</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_object &#123;</span><br><span class="line">Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.类实例结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>
<p>3.类实例结构_常用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取类的类名</span><br><span class="line">const char * class_getName ( Class cls );</span><br><span class="line"></span><br><span class="line">// 获取类的父类</span><br><span class="line">Class class_getSuperclass ( Class cls );</span><br><span class="line"></span><br><span class="line">// 判断给定的Class是否是一个元类</span><br><span class="line">BOOL class_isMetaClass ( Class cls );</span><br><span class="line"></span><br><span class="line">// 获取实例大小</span><br><span class="line">size_t class_getInstanceSize ( Class cls );</span><br><span class="line"></span><br><span class="line">// 获取类中指定名称实例成员变量的信息</span><br><span class="line">Ivar class_getInstanceVariable ( Class cls, const char *name );</span><br><span class="line"></span><br><span class="line">// 获取类成员变量的信息</span><br><span class="line">Ivar class_getClassVariable ( Class cls, const char *name );</span><br><span class="line"></span><br><span class="line">// 添加成员变量,方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用</span><br><span class="line">BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );</span><br><span class="line"></span><br><span class="line">// 获取整个成员变量列表 ，后续必须使用free释放Ivar这个数组对象</span><br><span class="line">Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );</span><br><span class="line"></span><br><span class="line">// 获取指定的属性</span><br><span class="line">objc_property_t class_getProperty ( Class cls, const char *name );</span><br><span class="line"></span><br><span class="line">// 获取属性列表</span><br><span class="line">objc_property_t * class_copyPropertyList ( Class cls, unsigned int *outCount );</span><br><span class="line"></span><br><span class="line">// 为类添加属性</span><br><span class="line">BOOL class_addProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );</span><br><span class="line"></span><br><span class="line">// 替换类的属性</span><br><span class="line">void class_replaceProperty ( Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount );</span><br></pre></td></tr></table></figure>
<p>4.类方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br><span class="line"></span><br><span class="line">struct objc_method &#123;</span><br><span class="line">SEL method_name                 OBJC2_UNAVAILABLE;  // 方法名</span><br><span class="line">char *method_types              OBJC2_UNAVAILABLE;</span><br><span class="line">IMP method_imp                  OBJC2_UNAVAILABLE;  // 方法实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.类方法_常用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 添加方法</span><br><span class="line">BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );</span><br><span class="line"></span><br><span class="line">// 获取实例方法</span><br><span class="line">Method class_getInstanceMethod ( Class cls, SEL name );</span><br><span class="line"></span><br><span class="line">// 获取类方法</span><br><span class="line">Method class_getClassMethod ( Class cls, SEL name );</span><br><span class="line"></span><br><span class="line">// 获取所有方法的数组</span><br><span class="line">Method * class_copyMethodList ( Class cls, unsigned int *outCount );</span><br><span class="line"></span><br><span class="line">// 替代方法的实现</span><br><span class="line">IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );</span><br><span class="line"></span><br><span class="line">// 返回方法的具体实现</span><br><span class="line">IMP class_getMethodImplementation ( Class cls, SEL name );</span><br><span class="line"></span><br><span class="line">IMP class_getMethodImplementation_stret ( Class cls, SEL name );</span><br><span class="line"></span><br><span class="line">// 类实例是否响应指定的selector</span><br><span class="line">BOOL class_respondsToSelector ( Class cls, SEL sel );</span><br></pre></td></tr></table></figure>
<p>6.实例方法_常用函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 调用指定方法的实现</span><br><span class="line">id method_invoke ( id receiver, Method m, ... );</span><br><span class="line"></span><br><span class="line">// 调用返回一个数据结构的方法的实现</span><br><span class="line">void method_invoke_stret ( id receiver, Method m, ... );</span><br><span class="line"></span><br><span class="line">// 获取方法名</span><br><span class="line">SEL method_getName ( Method m );</span><br><span class="line"></span><br><span class="line">// 返回方法的实现</span><br><span class="line">IMP method_getImplementation ( Method m );</span><br><span class="line"></span><br><span class="line">// 获取描述方法参数和返回值类型的字符串</span><br><span class="line">const char * method_getTypeEncoding ( Method m );</span><br><span class="line"></span><br><span class="line">// 获取方法的返回值类型的字符串</span><br><span class="line">char * method_copyReturnType ( Method m );</span><br><span class="line"></span><br><span class="line">// 获取方法的指定位置参数的类型字符串</span><br><span class="line">char * method_copyArgumentType ( Method m, unsigned int index );</span><br><span class="line"></span><br><span class="line">// 通过引用返回方法的返回值类型字符串</span><br><span class="line">void method_getReturnType ( Method m, char *dst, size_t dst_len );</span><br><span class="line"></span><br><span class="line">// 返回方法的参数的个数</span><br><span class="line">unsigned int method_getNumberOfArguments ( Method m );</span><br><span class="line"></span><br><span class="line">// 通过引用返回方法指定位置参数的类型字符串</span><br><span class="line">void method_getArgumentType ( Method m, unsigned int index, char *dst, size_t dst_len );</span><br><span class="line"></span><br><span class="line">// 返回指定方法的方法描述结构体</span><br><span class="line">struct objc_method_description * method_getDescription ( Method m );</span><br><span class="line"></span><br><span class="line">// 设置方法的实现</span><br><span class="line">IMP method_setImplementation ( Method m, IMP imp );</span><br><span class="line"></span><br><span class="line">// 交换两个方法的实现</span><br><span class="line">void method_exchangeImplementations ( Method m1, Method m2 );</span><br><span class="line"></span><br><span class="line">//函数调用</span><br><span class="line">objc_msgSend(receiver, selector)</span><br><span class="line">objc_msgSend(receiver, selector, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>
<p>7.方法选择器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 返回给定选择器指定的方法的名称</span><br><span class="line">const char * sel_getName ( SEL sel );</span><br><span class="line"></span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span><br><span class="line">SEL sel_registerName ( const char *str );</span><br><span class="line"></span><br><span class="line">// 在Objective-C Runtime系统中注册一个方法</span><br><span class="line">SEL sel_getUid ( const char *str );</span><br><span class="line"></span><br><span class="line">// 比较两个选择器</span><br><span class="line">BOOL sel_isEqual ( SEL lhs, SEL rhs );</span><br></pre></td></tr></table></figure>
<p>8.动态创建类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建一个新类和元类 extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</span><br><span class="line">Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );</span><br><span class="line"></span><br><span class="line">// 销毁一个类及其相关联的类</span><br><span class="line">void objc_disposeClassPair ( Class cls );</span><br><span class="line"></span><br><span class="line">// 在应用中注册由objc_allocateClassPair创建的类</span><br><span class="line">void objc_registerClassPair ( Class cls );</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 例子1：</span><br><span class="line">Class cls = objc_allocateClassPair(MyClass.class, &quot;MySubClass&quot;, 0);</span><br><span class="line">class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, &quot;v@:&quot;);</span><br><span class="line">class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, &quot;v@:&quot;);</span><br><span class="line">class_addIvar(cls, &quot;_ivar1&quot;, sizeof(NSString *), log(sizeof(NSString *)), &quot;i&quot;);</span><br><span class="line">objc_property_attribute_t type = &#123;&quot;T&quot;, &quot;@\&quot;NSString\&quot;&quot;&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; &quot;C&quot;, &quot;&quot; &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; &quot;V&quot;, &quot;_ivar1&quot;&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line">class_addProperty(cls, &quot;property2&quot;, attrs, 3);</span><br><span class="line">objc_registerClassPair(cls);</span><br><span class="line">id instance = [[cls alloc] init];</span><br><span class="line">[instance performSelector:@selector(submethod1)];</span><br><span class="line">[instance performSelector:@selector(method1)];</span><br></pre></td></tr></table></figure>
<p>9.动态创建对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 创建类实例</span><br><span class="line">id class_createInstance ( Class cls, size_t extraBytes );</span><br><span class="line"></span><br><span class="line">// 在指定位置创建类实例</span><br><span class="line">id objc_constructInstance ( Class cls, void *bytes );</span><br><span class="line"></span><br><span class="line">// 销毁类实例</span><br><span class="line">void * objc_destructInstance ( id obj );</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 例子1：</span><br><span class="line">id theObject = class_createInstance(NSString.class, sizeof(unsigned));</span><br><span class="line">id str1 = [theObject init];</span><br><span class="line">NSLog(@&quot;%@&quot;, [str1 class]);</span><br><span class="line">id str2 = [[NSString alloc] initWithString:@&quot;test&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, [str2 class]);</span><br></pre></td></tr></table></figure>
<p>10.成员变量、属性</p>
<p>Ivar 结构：Ivar是表示实例变量的类型，其实际是一个指向objc_ivar结构体的指针，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct objc_ivar *Ivar;</span><br><span class="line">struct objc_ivar &#123;</span><br><span class="line">char *ivar_name                 OBJC2_UNAVAILABLE;  // 变量名</span><br><span class="line">char *ivar_type                 OBJC2_UNAVAILABLE;  // 变量类型</span><br><span class="line">int ivar_offset                 OBJC2_UNAVAILABLE;  // 基地址偏移字节</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">int space                       OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.objc_property_t 属性结构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">typedef struct objc_property *objc_property_t;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">const char *name;           // 特性名</span><br><span class="line">const char *value;          // 特性值</span><br><span class="line">&#125; objc_property_attribute_t;</span><br></pre></td></tr></table></figure>
<p>12.常用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 获取成员变量名</span><br><span class="line">const char * ivar_getName ( Ivar v );</span><br><span class="line"></span><br><span class="line">// 获取成员变量类型编码</span><br><span class="line">const char * ivar_getTypeEncoding ( Ivar v );</span><br><span class="line"></span><br><span class="line">// 获取成员变量的偏移量</span><br><span class="line">ptrdiff_t ivar_getOffset ( Ivar v );</span><br><span class="line"></span><br><span class="line">// 设置关联对象</span><br><span class="line">void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );</span><br><span class="line"></span><br><span class="line">// 获取关联对象</span><br><span class="line">id objc_getAssociatedObject ( id object, const void *key );</span><br><span class="line"></span><br><span class="line">// 移除关联对象</span><br><span class="line">void objc_removeAssociatedObjects ( id object );</span><br><span class="line"></span><br><span class="line">// 获取属性名</span><br><span class="line">const char * property_getName ( objc_property_t property );</span><br><span class="line"></span><br><span class="line">// 获取属性特性描述字符串</span><br><span class="line">const char * property_getAttributes ( objc_property_t property );</span><br><span class="line"></span><br><span class="line">// 获取属性中指定的特性</span><br><span class="line">char * property_copyAttributeValue ( objc_property_t property, const char *attributeName );</span><br><span class="line"></span><br><span class="line">// 获取属性的特性列表</span><br><span class="line">objc_property_attribute_t * property_copyAttributeList ( objc_property_t property, unsigned int *outCount );</span><br></pre></td></tr></table></figure>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2016/08/09/iOS-Block/" title="iOS-Block" itemprop="url">iOS-Block</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="JJBoy" target="_blank" itemprop="author">JJBoy</a>
		
  <p class="article-time">
    <time datetime="2016-08-08T22:02:38.000Z" itemprop="datePublished"> Published 2016-08-09</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Block有什么用？"><a href="#Block有什么用？" class="headerlink" title="Block有什么用？"></a>Block有什么用？</h2><p>1.代替类</p>
<p>2.什么时候代替类，当类只有一个函数的时候</p>
<h2 id="Block的本质？"><a href="#Block的本质？" class="headerlink" title="Block的本质？"></a>Block的本质？</h2><p>1.类和闭包的本质是一样的</p>
<p>2.类和闭包哪个好用：答案是类</p>
<p>3.Block的另一个名字闭包</p>
<p>4.block、代码块、闭包，都是只一样的玩意，是一个GCC 非常模糊的特性，以及 Clang 也有的特性是</p>
<p>5.Block是带有自动变量的匿名函数；匿名函数顾名思义就是不带名字的函数，在C语言中不允许这样的方法存在，而在OC中的Block则可以用指针来直接调用一个函数，但虽说如此我们还是需要知道指针的名称。</p>
<p>6.自动变量在Block中的具体表现就是截获自动变量</p>
<h2 id="一个标准的Block"><a href="#一个标准的Block" class="headerlink" title="一个标准的Block"></a>一个标准的Block</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">^ NSString *(NSString *a,NSString *b)&#123;</span><br><span class="line">return a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">* “^”这个符号表示这是一个Block；</span><br><span class="line"></span><br><span class="line">* 返回值类型：NSString *表示返回值。</span><br><span class="line"></span><br><span class="line">* 参数列表：(NSString a,NSString b)这个括号中是Block的参数，语法和C语言类似</span><br><span class="line"></span><br><span class="line">* 变量名在哪里？</span><br></pre></td></tr></table></figure>
<h2 id="Block调用"><a href="#Block调用" class="headerlink" title="Block调用"></a>Block调用</h2><p>1.Block调用1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int b = 0;// 初始化b变量</span><br><span class="line">void (^blockName)() = ^&#123;</span><br><span class="line">NSLog(@&quot;Input:b=%d&quot;,b);//打印b变量</span><br><span class="line">&#125;;</span><br><span class="line">b = 3;// 对b变量进行修改，无法修改，原因如下</span><br><span class="line">blockName();// 调用blockName</span><br><span class="line"></span><br><span class="line">原因：虽然我们在调用blockName之前改变了b的值，但是输出的还是blockName编译时候b的值，所以截获瞬间自动变量就是：在blockName中会保存变量的值，而不会随变量的值的改变而改变。</span><br></pre></td></tr></table></figure>
<p>2.Block调用2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int b = 0;</span><br><span class="line">void (^blockName)() = ^&#123;</span><br><span class="line">b = 3;</span><br><span class="line">&#125;;</span><br><span class="line">这段代码编译出错，编译器提示的大概就是不能在Block中改变变量的值。因为在Block中截获了变量的瞬间值以后就不能再改变变量的值，如果想要在Block中改变变量的值，那么我们只需要在变量声明的时候加上__Block修饰符，像这样：</span><br><span class="line"></span><br><span class="line">__block int b = 0;</span><br><span class="line">void (^blockName)() = ^&#123;</span><br><span class="line">b = 3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Block使用技巧"><a href="#Block使用技巧" class="headerlink" title="Block使用技巧"></a>Block使用技巧</h2><p>1.修改闭包内部变量注意，如果该变量在Block外部，需要在变量前面加上__block关键字</p>
<p>2.在Block中常常会用到weakSelf和strong来处理block的产生循环引用的问题</p>
<p>3.代码块如果在闭合的圆括号内的话，会返回最后语句的值;例子中返回的是url</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NSURL *url = (&#123;</span><br><span class="line">NSString *urlString = [NSString stringWithFormat:@&quot;%@/%@&quot;, baseURLString, endpoint];</span><br><span class="line">[NSURL URLWithString:urlString];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>4.在Block中不可以对C语言数组进行操作，原因是：不支持</p>
<p>5.Block可以定义在方法内部，也可以定义在方法外部；</p>
<p>6.只有调用Block时候，才会执行其内部方法</p>
<h2 id="weakSelf和strongSelf"><a href="#weakSelf和strongSelf" class="headerlink" title="weakSelf和strongSelf"></a>weakSelf和strongSelf</h2><ul>
<li><p>直接在 block 里面使用关键词 self</p>
</li>
<li><p>在 block 外定义一个 __weak 的 引用到 self，并且在 block 里面使用这个弱引用</p>
</li>
<li><p>在 block 外定义一个 <strong>weak 的 引用到 self，并在在 block 内部通过这个弱引用定义一个 </strong>strong 的引用。</p>
</li>
<li><p>注意：当 block并没有被self对象所引用 时，一般可以直接使用self</p>
</li>
<li><p>weakSelf和strongSelf的选择是：如果block不是属性则使用self；是属性但block中调用单个self的方法时用weakSelf；多个方法用strongSelf</p>
</li>
</ul>
<h2 id="使用weakSelf"><a href="#使用weakSelf" class="headerlink" title="使用weakSelf"></a>使用weakSelf</h2><p>1.持有Block；completionHandler是一个Block；被self调用，那正常来说，block里面不能用self调用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyViewController *myController = [[MyViewController alloc] init];</span><br><span class="line">[self presentViewController:myController animated:YES completion:self.completionHandler];// 这里是self对block持有</span><br></pre></td></tr></table></figure>
<p>2.当block对象被self持有时，一定要使用weakself避免循环引用,下面的weakSelf如果换成了self就会循环引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">self.completionHandler = ^&#123; // self.completionHandler表示self调用了block，block里面又使用self，用weakSelf替换</span><br><span class="line">NSLog(@&quot;%@&quot;, weakSelf);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.来一个没有使用weakSelf导致运行循环的例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</span><br><span class="line">[self doSomethingWithData:data];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="使用strongSelf"><a href="#使用strongSelf" class="headerlink" title="使用strongSelf"></a>使用strongSelf</h2><p>1.参考《解决Block循环引用》</p>
<p>2.什么时候使用weakSelf和strongSelf：参考《weakSelf和strongSelf》</p>
<p>3.多个方法用strongSelf</p>
<h2 id="解决Block循环引用"><a href="#解决Block循环引用" class="headerlink" title="解决Block循环引用"></a>解决Block循环引用</h2><p>1.什么时候会出现循环引用？简单来说就是双边引用, 如果block是self类的property (此时self已经retain了block), 然后在block内又引用了self, 这个情况下就肯定会循环引用了</p>
<p>2.在block体内define一个strong的self, 然后执行的时候判断下self是否还在, 如果在就继续执行下面的操作, 否则return或抛出异常.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__weak typeof(self) weakSelf = self;</span><br><span class="line">myObj.myBlock =  ^&#123;</span><br><span class="line">__strong typeof(self) strongSelf = weakSelf;</span><br><span class="line">if (strongSelf) &#123;</span><br><span class="line">[strongSelf doSomething]; // strongSelf != nil</span><br><span class="line">// preemption, strongSelf still not nil</span><br><span class="line">[strongSelf doSomethingElse]; // strongSelf != nil</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// Probably nothing...</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>3.来一个使用strongSelf错误的例子,因为block里面调用了多个方法，所以建议用strongSelf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">[self executeBlock:^(NSData *data, NSError *error) &#123;</span><br><span class="line">[weakSelf doSomethingWithData:data];</span><br><span class="line">[weakSelf doSomethingWithData:data];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1.weakSelf和strongSelf的选择是：如果block不是属性则使用self；是属性但block中调用单个self的方法时用weakSelf；多个方法用strongSelf</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=null&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="JJBoy">JJBoy</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
